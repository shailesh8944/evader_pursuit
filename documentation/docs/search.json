[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pani Simulator",
    "section": "",
    "text": "Pani Simulator\nPani (which means \\(\\textit{water}\\) in Hindi) is a high fidelity marine vessel simulator. It is built in a manner such that minimum backend edits are required by the user and the simulator can be both configured and run in an intuitive lightweight GUI application which runs on the web. An attempt to make it as ‚ÄúMicrosoft‚Äôs Flight Simualtor‚Äù but for marine vessels has been made.\nThe simulator can be used to configure a new marine vessel, simulate sensors such as DVL, IMU, LiDAR and Camera, and control the vessel either via teleop input or custom files for autonomous tasks. The simulator supports multiple agents which is useful for swarm autonomy tasks or to develop better collision avoidance algorithms.\nThe project has been made open source to allow for further development of this simulator and add additional features to make it more versatile.",
    "crumbs": [
      "Pani Simulator"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Pani Simulator",
    "section": "Overview",
    "text": "Overview\nThe Simulator is majorly divided into two parts:\n\nVessel Configurator\nVessel Simulation\n\nThe Vessel Configurator is what allows you to configure a new marine vessel. You can load a FBX Geometry file, select individual components such as control surfaces, thrusters, sensors and configure their parameters via the interactive GUI. If you like a more geeky experience, you can edit the input files manually as well. There are also options to enter the non-linear hydrodynamics coefficients for the vessel (which we plan to integrate with our in-house system identification algorithm, in future), set vessel geometry parameters and specify initial conditions. This is also where you will setup the simulation parameters such as time, time-step, geofence, GPS datum and physical constants (gravity, density etc). It also supports the output from our in-house hydrodynamics program , which gives the added mass coefficients and wave hydrodynamics of the vessel. Once you are done with the vessel configuration, the program auto generates the input files required for the simulation to run.\n\n\n\nVessel Configurator\n\n\nThe Vessel Simulation is where the actual simulation takes place. It follows the dynamics as per the parameters you set in the Vessel Configurator. This is where you can also custom code your control and guidance algorithms which will publish the required data in ROS2 to make the vessel run. Currently the sensors are simulated with added noise whose outputs you can see in the ROS2 terminal, or from the GUI. We soon plan to add modelling for the simulator with real world physics.\n\n\n\nWay-point trackingSimulation Visualization",
    "crumbs": [
      "Pani Simulator"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Pani Simulator",
    "section": "Key Features",
    "text": "Key Features\n\nRealistic Physics: Follows dyanmics modelling as defined by Fossen‚Äôs \nModular Architecture: Easy integration of custom vessel models, sensors, and controllers\nROS2 Integration: Native support for Robot Operating System 2 (ROS2) for distributed robotics applications\nWeb Application: Lightweight web application for configuring and running the simulation\nMultiple Agents: Simulate multiple vessels in the same environment",
    "crumbs": [
      "Pani Simulator"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-documentation",
    "href": "index.html#how-to-use-this-documentation",
    "title": "Pani Simulator",
    "section": "How to Use This Documentation",
    "text": "How to Use This Documentation\nNavigate through the sections using the sidebar. The documentation discusses the Setup, theory on the Kinematics and Dynamics used in the simulator, the coordinate systems used for various components (control surfaces, thrusters, sensors and Body centre), the python simulator backend and how to use the Panisim vessel configurator and the Panisim vessel simulator.",
    "crumbs": [
      "Pani Simulator"
    ]
  },
  {
    "objectID": "rawFiles/setup.html",
    "href": "rawFiles/setup.html",
    "title": "Setup",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "rawFiles/setup.html#prerequisites",
    "href": "rawFiles/setup.html#prerequisites",
    "title": "Setup",
    "section": "",
    "text": "Git installed on your system\nDocker installed on your system\nBasic understanding of terminal commands\nPython version 3.10 or higher",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "rawFiles/setup.html#cloning-the-repository",
    "href": "rawFiles/setup.html#cloning-the-repository",
    "title": "Setup",
    "section": "Cloning the Repository",
    "text": "Cloning the Repository\n\nOpen a terminal window\nClone the repository using the following command:\ngit clone https://github.com/MarineAutonomy/makara.git\nNavigate to the cloned repository:\ncd makara\nSwitch to the mavymini branch:\ngit checkout mavymini",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "rawFiles/setup.html#building-the-docker-image",
    "href": "rawFiles/setup.html#building-the-docker-image",
    "title": "Setup",
    "section": "Building the Docker Image",
    "text": "Building the Docker Image\nBefore running the simulator, you need to build the Docker image:\n\nEnsure you‚Äôre in the root directory of the cloned repository\nBuild the Docker image by executing:\n./ros2_devdocker.sh\nWait for the build process to complete (this may take several minutes depending on your internet connection and system performance)",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "rawFiles/setup.html#troubleshooting",
    "href": "rawFiles/setup.html#troubleshooting",
    "title": "Setup",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nDocker issues: Ensure Docker is installed and running on your system\nPermission issues: If you encounter permission errors when running scripts, try prefixing the commands with sudo",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "rawFiles/quickstart.html",
    "href": "rawFiles/quickstart.html",
    "title": "Quickstart",
    "section": "",
    "text": "After building the Docker image, you can start the simulator:\n\nFrom the root directory of the repository, run the following script in your terminal:\n./ros2_simulator.sh\nOnce the simulator starts, it will display the ROS2 topics available in the terminal. You should see an output similar to this:\n   ==================================================\n   üöÄ ROS2 Simulation Started Successfully!\n   ==================================================\n\nüì° Available ROS2 Topics:\n------------------------------\n/parameter_events\n/rosout\n/sookshma_00/Rudder_1/encoder\n/sookshma_00/actuator_cmd\n/sookshma_00/imu/data\n/sookshma_00/odometry\n/sookshma_00/odometry_sim\n/sookshma_00/uwb\n/sookshma_00/vessel_state\n/sookshma_00/vessel_states_ekf\n/sookshma_00/waypoints\n\nüîç View Topic Data:\n------------------------------\n1. Open a new terminal:\n    docker exec -it panisim bash\n\n2. Subscribe to a topic:\n    ros2 topic echo &lt;topic_name&gt;\n\nüìù Example:\n    ros2 topic echo /vessel_0/odometry_sim\n\n==================================================\n\nTo inspect the data published on these topics, follow these steps:\n\nOpen a new terminal window.\nEnter the Docker container by executing the following command in a new terminal:\n\ndocker exec -it panisim bash\n\nSubscribe to a specific topic using the ros2 topic echo command. Replace &lt;topic_name&gt; with the actual topic you want to inspect.\n\nros2 topic echo &lt;topic_name&gt;\nFor example, to view the odometry data for mavymini_00, you would use:\nros2 topic echo /sookshma_00/odometry_sim\n\n\n\n\n\n\n\nNote\n\n\n\nThe specific topic names may vary depending on the agents activated in your /inputs/simulation_input.yml configuration file.\n\n\nCurrently, the example vessel is configure with an initial velocity of 0.5m/s. (You can change this by editing the /inputs/simulation_input.yml file.)\nA Web-based visualization GUI would have started automatically. You can access it by opening a new browser tab and navigating to http://localhost:8000.\n\n\n\nWeb-based visualization GUI\n\n\nThis visualization GUI shows you the current state of the vessel, including its position, velocity, orientation and actuator data.\nYou can also see the 6 DOF of the vessel via the ‚ÄúOpen 3D View‚Äù button. A new window will appear showing you a box shaped vessel with its position and orientation in the simulation.\n\n\n\n3D View\n\n\nAnd that‚Äôs it! The simulation is up and running and now you can start any other ROS nodes to command the vessel actuators, perform Extended Kalman Filtering, or anything else you want. We will be covering a waypoint tracking example to show you how you can write your own ROS2 nodes to control your vessel.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "rawFiles/Kinematics/Kinematics.html",
    "href": "rawFiles/Kinematics/Kinematics.html",
    "title": "Kinematics",
    "section": "",
    "text": "Overview\nThe Kinematics module (module_kinematics.py) provides a comprehensive set of mathematical functions for handling coordinate transformations, rotation representations, and kinematic calculations essential for marine vehicle simulation.",
    "crumbs": [
      "Kinematics"
    ]
  },
  {
    "objectID": "rawFiles/Kinematics/Kinematics.html#overview",
    "href": "rawFiles/Kinematics/Kinematics.html#overview",
    "title": "Kinematics",
    "section": "",
    "text": "Tip\n\n\n\nThis module serves as the mathematical foundation for all spatial transformations in the simulator.",
    "crumbs": [
      "Kinematics"
    ]
  },
  {
    "objectID": "rawFiles/Kinematics/Kinematics.html#coordinate-frames",
    "href": "rawFiles/Kinematics/Kinematics.html#coordinate-frames",
    "title": "Kinematics",
    "section": "Coordinate Frames",
    "text": "Coordinate Frames\nThe simulator utilizes several key coordinate frames:\n\nEarth Centered Inertial (ECI) frame {i}: An inertial frame with its origin at the Earth‚Äôs center. It does not rotate with the Earth‚Äôs rotation.\nEarth Centered Earth Fixed (ECEF) frame {e}: Rotates with the Earth. Its origin is at the Earth‚Äôs center. The x-axis passes through the intersection of the prime meridian and the equator, the z-axis aligns with the Earth‚Äôs rotation axis, and the y-axis completes the right-handed system.\nNorth-East-Down (NED) frame {n}: A local tangent frame fixed to a point on the Earth‚Äôs surface (or a reference point). The x-axis points North, the y-axis points East, and the z-axis points Down, perpendicular to the Earth‚Äôs ellipsoid surface. This is the primary navigation frame.\nBody frame {b}: An orthogonal frame fixed to the vehicle. The x-axis points forward, the y-axis points right (starboard), and the z-axis points down.",
    "crumbs": [
      "Kinematics"
    ]
  },
  {
    "objectID": "rawFiles/Kinematics/Kinematics.html#function-categories",
    "href": "rawFiles/Kinematics/Kinematics.html#function-categories",
    "title": "Kinematics",
    "section": "Function Categories",
    "text": "Function Categories\n\nRotation Representation Conversions\n\n\n\n\n\ngraph TD\n    EA[Euler Angles] -- eul_to_rotm --&gt; RM[Rotation Matrix]\n    RM -- rotm_to_eul --&gt; EA\n    EA -- eul_to_quat --&gt; Q[Quaternion]\n    Q -- quat_to_eul --&gt; EA\n    Q -- quat_to_rotm --&gt; RM\n    RM -- rotm_to_quat --&gt; Q\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\neul_to_rotm(eul, order='ZYX', deg=False)\nConverts Euler angles (roll \\(\\phi\\), pitch \\(\\theta\\), yaw \\(\\psi\\)) to a 3x3 rotation matrix that transforms vectors from the Body frame {b} to the NED frame {n}. Assumes ZYX rotation order. Angles can be in radians or degrees.\n\n\nrotm_to_eul(rotm, order='ZYX', prev_eul=None, deg=False, silent=True)\nConverts a 3x3 rotation matrix back to Euler angles (roll \\(\\phi\\), pitch \\(\\theta\\), yaw \\(\\psi\\)). Handles potential ambiguities and gimbal lock using previous Euler angles (prev_eul) if provided. Can output in radians or degrees.\n\n\neul_to_quat(eul, order='ZYX', deg=False)\nConverts Euler angles (roll \\(\\phi\\), pitch \\(\\theta\\), yaw \\(\\psi\\)) to a unit quaternion \\([q_w, q_x, q_y, q_z]\\). Assumes ZYX rotation order. Angles can be in radians or degrees.\n\n\nquat_to_eul(quat, order='ZYX', deg=False, prev_quat=None, silent=True)\nConverts a unit quaternion \\([q_w, q_x, q_y, q_z]\\) to Euler angles (roll \\(\\phi\\), pitch \\(\\theta\\), yaw \\(\\psi\\)). Handles potential ambiguities using prev_quat if provided. Can output in radians or degrees.\n\n\nquat_to_rotm(quat)\nConverts a unit quaternion \\([q_w, q_x, q_y, q_z]\\) to a 3x3 rotation matrix that transforms vectors from the Body frame {b} to the NED frame {n}.\n\n\nrotm_to_quat(rotm)\nConverts a 3x3 rotation matrix (Body to NED) to a unit quaternion \\([q_w, q_x, q_y, q_z]\\).\n\n\n\n\n\nQuaternion Operations\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nquat_multiply(q1, q2)\nMultiplies two quaternions \\(\\mathbf{q}_1 \\otimes \\mathbf{q}_2\\). Order matters: represents rotation \\(\\mathbf{q}_2\\) followed by rotation \\(\\mathbf{q}_1\\).\n\n\nquat_conjugate(quat)\nComputes the conjugate of a quaternion \\(\\mathbf{q}^* = [q_w, -q_x, -q_y, -q_z]^T\\).\n\n\nrotate_vec_by_quat(vec_a, q_a_b)\nRotates a 3D vector vec_a using the quaternion rotation q_a_b (representing rotation from frame A to frame B) to get the vector in frame B. Computes \\(\\mathbf{v}_b' = \\mathbf{q}_{a \\to b} \\otimes \\mathbf{v}_a' \\otimes \\mathbf{q}_{a \\to b}^*\\).\n\n\n\n\n\nRate Calculations\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\neul_rate_matrix(eul, order='ZYX', deg=False)\nComputes the 3x3 transformation matrix \\(\\mathbf{T}(\\boldsymbol{\\eta})\\) that relates body-frame angular velocity \\(\\boldsymbol{\\omega}^b\\) to Euler angle rates \\(\\dot{\\boldsymbol{\\eta}}\\) via \\(\\dot{\\boldsymbol{\\eta}} = \\mathbf{T}(\\boldsymbol{\\eta}) \\boldsymbol{\\omega}^b\\). Assumes ZYX order.\n\n\nquat_rate_matrix(quat)\nComputes the 4x3 transformation matrix \\(\\mathbf{E}(\\mathbf{q})\\) that relates body-frame angular velocity \\(\\boldsymbol{\\omega}^b\\) to quaternion rates \\(\\dot{\\mathbf{q}}\\) via \\(\\dot{\\mathbf{q}} = \\frac{1}{2} \\mathbf{E}(\\mathbf{q}) \\boldsymbol{\\omega}^b\\).\n\n\neul_rate(eul, w, order='ZYX')\nCalculates Euler angle rates \\([\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi}]\\) given current Euler angles eul and body-frame angular velocity w = \\([p, q, r]^T\\). Uses eul_rate_matrix.\n\n\nquat_rate(quat, w)\nCalculates quaternion rates \\([\\dot{q}_w, \\dot{q}_x, \\dot{q}_y, \\dot{q}_z]\\) given the current quaternion quat and body-frame angular velocity w = \\([p, q, r]^T\\). Uses quat_rate_matrix.\n\n\ndeul_dquat(quat)\nComputes the 3x4 Jacobian matrix \\(\\frac{\\partial \\boldsymbol{\\eta}}{\\partial \\mathbf{q}}\\), representing the partial derivatives of Euler angles with respect to quaternion components.\n\n\ndquat_deul(quat)\nComputes the 4x3 Jacobian matrix \\(\\frac{\\partial \\mathbf{q}}{\\partial \\boldsymbol{\\eta}}\\), representing the partial derivatives of quaternion components with respect to Euler angles. Requires converting quat to eul internally first.\n\n\n\n\n\nNavigation Functions\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nssa(ang, deg=False)\nConverts an angle (in radians or degrees) to its smallest signed angle representation within the range \\((-\\pi, \\pi]\\) radians or \\((-180, 180]\\) degrees.\n\n\nclip(value, threshold)\nLimits the input value to the range [-threshold, threshold].\n\n\nned_to_llh(ned, llh0)\nConverts a position vector ned = [North, East, Down] relative to a reference point llh0 = [lat0, lon0, h0] into absolute geodetic coordinates llh = [latitude, longitude, height]. Uses WGS84 ellipsoid model.\n\n\nllh_to_ned(llh, llh0)\nConverts an absolute geodetic position llh = [lat, lon, h] into a local NED position vector ned = [North, East, Down] relative to a reference point llh0 = [lat0, lon0, h0]. Uses WGS84 ellipsoid model.\n\n\ngenerate_waypoints()\nGenerates a predefined sequence of waypoints as LLH coordinates for a rectangular survey pattern relative to a specific datum location (IITM lake). Returns a numpy array of [lat, lon, height] waypoints.\n\n\nrotm_ned_to_ecef(llh)\nComputes the 3x3 rotation matrix \\(\\mathbf{R}_n^e\\) that transforms vectors from the local NED frame (defined at llh) to the ECEF frame.\n\n\n\n\n\nUtility Functions\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nSmat(vec)\nCreates the 3x3 skew-symmetric matrix \\(\\mathbf{S}(\\mathbf{v})\\) corresponding to the input 3D vector vec. Used for representing cross products as matrix multiplications (\\(\\mathbf{a} \\times \\mathbf{b} = \\mathbf{S}(\\mathbf{a}) \\mathbf{b}\\)).",
    "crumbs": [
      "Kinematics"
    ]
  },
  {
    "objectID": "rawFiles/Kinematics/Kinematics.html#usage-examples",
    "href": "rawFiles/Kinematics/Kinematics.html#usage-examples",
    "title": "Kinematics",
    "section": "Usage Examples",
    "text": "Usage Examples\n\nCoordinate Transformations\nimport numpy as np\nfrom mav_simulator.module_kinematics import eul_to_rotm, llh_to_ned\n\n# Convert Euler angles to rotation matrix\neuler_angles = np.array([0.1, 0.2, 0.3])  # [roll, pitch, yaw] in radians\nR = eul_to_rotm(euler_angles)  # Rotation matrix\n\n# Convert latitude, longitude, height to NED coordinates\nreference_point = np.array([60.0, 10.0, 0.0])  # [lat, lon, height]\ntarget_point = np.array([60.001, 10.001, 10.0])  # [lat, lon, height]\nned_coords = llh_to_ned(target_point, reference_point)\n\n\nRotation Representations\nfrom mav_simulator.module_kinematics import eul_to_quat, quat_to_rotm\n\n# Convert from Euler angles to quaternion\neuler_angles = np.array([0.1, 0.2, 0.3])  # [roll, pitch, yaw] in radians\nquaternion = eul_to_quat(euler_angles)\n\n# Convert from quaternion to rotation matrix\nR = quat_to_rotm(quaternion)",
    "crumbs": [
      "Kinematics"
    ]
  },
  {
    "objectID": "rawFiles/Kinematics/Kinematics.html#best-practices",
    "href": "rawFiles/Kinematics/Kinematics.html#best-practices",
    "title": "Kinematics",
    "section": "Best Practices",
    "text": "Best Practices\n\nUse the ssa() function to normalize angles when working with Euler angles\nBe consistent with the rotation order convention throughout your code (the default is ‚ÄòZYX‚Äô)\nWhen transforming between frames, always keep track of the reference frames involved",
    "crumbs": [
      "Kinematics"
    ]
  },
  {
    "objectID": "rawFiles/Dynamics/Dynamics.html",
    "href": "rawFiles/Dynamics/Dynamics.html",
    "title": "Dynamics",
    "section": "",
    "text": "Overview\nThe Dynamics modules (class_vessel.py and calculate_hydrodynamics.py) implement the mathematical foundation for simulating the motion of marine vehicles through water. The simulator uses Fossen‚Äôs nonlinear 6-DOF equation of motion:\n\\[M\\dot{\\nu}+C(\\nu)\\nu+D(\\nu)\\nu+g(\\eta) = \\tau\\]\nwhere,",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "rawFiles/Dynamics/Dynamics.html#overview",
    "href": "rawFiles/Dynamics/Dynamics.html#overview",
    "title": "Dynamics",
    "section": "",
    "text": "\\(M = M_{RB} + M_A\\) is the mass matrix, combining rigid body mass \\(M_{RB}\\) and added mass \\(M_A\\)\n\\(C(\\nu) = C_{RB}(\\nu) + C_A(\\nu)\\) is the Coriolis and centripetal matrix\n\\(D(\\nu)\\) is the hydrodynamic damping matrix\n\\(g(\\eta)\\) is the gravitational and buoyancy force vector\n\\(\\tau\\) is the control force vector from thrusters and control surfaces\n\\(\\nu = [u, v, w, p, q, r]^T\\) is the velocity vector in the body frame\n\\(\\eta = [x, y, z, \\phi, \\theta, \\psi]^T\\) is the position and orientation vector\n\n\n\n\n\n\n\nTip\n\n\n\nThe dynamics modules serve as the core of the simulation, determining how forces and moments translate into vessel motion through water.",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "rawFiles/Dynamics/Dynamics.html#state-representation",
    "href": "rawFiles/Dynamics/Dynamics.html#state-representation",
    "title": "Dynamics",
    "section": "State Representation",
    "text": "State Representation\nThe vessel state is represented as a vector combining velocities, position, orientation, control surface angles, and thruster states:\n\\(\\text{state} = [\\nu^T, \\eta_{pos}^T, \\eta_{rot}^T, \\delta^T, n^T]^T\\)\nWhere: - \\(\\nu = [u, v, w, p, q, r]^T\\) are the linear and angular velocities in the body frame - \\(\\eta_{pos} = [x, y, z]^T\\) is the position in the NED frame - \\(\\eta_{rot}\\) is the orientation, either as Euler angles \\([\\phi, \\theta, \\psi]^T\\) or quaternion \\([q_0, q_1, q_2, q_3]^T\\) - \\(\\delta\\) is the vector of control surface angles - \\(n\\) is the vector of thruster rotational speeds (RPM)",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "rawFiles/Dynamics/Dynamics.html#components-of-the-dynamic-equation",
    "href": "rawFiles/Dynamics/Dynamics.html#components-of-the-dynamic-equation",
    "title": "Dynamics",
    "section": "Components of the Dynamic Equation",
    "text": "Components of the Dynamic Equation\n\n\n\n\n\ngraph TD\n    A[Mass Matrix M] --&gt; EOM[Equation of Motion]\n    B[Coriolis Matrix C] --&gt; EOM\n    C[Damping Matrix D] --&gt; EOM\n    D[Restoring Forces g] --&gt; EOM\n    E[Control Forces œÑ] --&gt; EOM\n    EOM --&gt; ODE[vessel_ode]\n    ODE --&gt; IV[solve_ivp]\n    IV --&gt; ST[Vessel State]\n\n\n\n\n\n\n\nMass Matrix (\\(M\\))\nThe mass matrix \\(M\\) combines the rigid-body inertia matrix \\(M_{RB}\\) and the added mass matrix \\(M_A\\):\n\\[M = M_{RB} + M_A\\]\n\nRigid-body Mass Matrix (\\(M_{RB}\\))\nThe rigid-body mass matrix is generated in the _generate_mass_matrix method in calculate_hydrodynamics.py:\n\\[M_{RB} = \\begin{bmatrix} m I_{3 \\times 3} & -m S(r_G) \\\\ m S(r_G) & I_G \\end{bmatrix}\\]\nWhere: - \\(m\\) is the vessel mass - \\(I_{3 \\times 3}\\) is the 3√ó3 identity matrix - \\(r_G\\) is the center of gravity vector relative to the origin of the body frame - \\(S(r_G)\\) is the skew-symmetric matrix of \\(r_G\\) (implemented by Smat() in module_kinematics.py) - \\(I_G\\) is the inertia tensor calculated from the radii of gyration\ndef _generate_mass_matrix(self, CG, mass, gyration):\n    # Calculate gyration tensor about vessel frame\n    xprdct2 = np.diag(gyration)**2 - Smat(CG)@Smat(CG)\n    \n    # Generate the inertia matrix using radii of gyration\n    inertia_matrix = xprdct2 * mass\n\n    # Generate the mass matrix\n    mass_matrix = np.zeros((6,6))\n    mass_matrix[0:3][:, 0:3] = mass * np.eye(3)\n    mass_matrix[3:6][:, 3:6] = inertia_matrix\n    mass_matrix[0:3][:, 3:6] = -Smat(CG) * mass\n    mass_matrix[3:6][:, 0:3] = Smat(CG) * mass\n\n    return mass_matrix\n\n\nAdded Mass Matrix (\\(M_A\\))\nThe added mass matrix represents the added inertia due to accelerating the surrounding fluid. It‚Äôs calculated from hydrodynamic data obtained from HydRA (You can also enter custom hydrodynamics added mass coefficients (example Y_vd) in the hydrodynamics.yml input file instead of using HydRA, as discussed in the Inputs section).\n\\[M_A = \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}\\]\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ncalculate_added_mass_from_hydra(hydra_file)\nComputes the added mass matrix from HydRA data file containing frequency-dependent hydrodynamic coefficients. Extracts zero-frequency added mass for most terms, but computes heave, roll, and pitch terms at their natural frequencies for better accuracy.\n\n\n\ndef calculate_added_mass_from_hydra(self, hydra_file):\n    # Load hydrodynamic data\n    with open(hydra_file, 'r') as file:\n        mdict = json.load(file)\n    \n    # Extract arrays from data\n    omg = np.array(mdict['w'])      # Frequency array\n    AM = np.array(mdict['AM'])      # Added mass array\n    \n    # Extract zero-frequency added mass\n    A_zero = AM[1, :, :, 0, 0]\n    \n    # Calculate natural frequencies and\n    # interpolate added mass at those frequencies\n    # ...\n    \n    # Return properly transformed added mass matrix\n    return A\n\n\n\n\n\n\nNote\n\n\n\nThe added mass calculated from HydRA is in ENU frame and so it is converted to NED frame in the calculate_added_mass_from_hydra function.\n\n\n\n\n\nCoriolis and Centripetal Matrix\nThe Coriolis matrix (\\(C(\\nu)\\)) accounts for forces arising from motion in a rotating reference frame (Body frame is rotating with respect to NED frame):\n\\[C(\\nu) = C_{RB}(\\nu) + C_A(\\nu)\\]\nThese matrices are calculated using:\n\\[C_{RB}(\\nu) = \\begin{bmatrix} 0_{3 \\times 3} & -S(M_{11} v_1 + M_{12} v_2) \\\\\n-S(M_{11} v_1 + M_{12} v_2) & -S(M_{21} v_1 + M_{22} v_2) \\end{bmatrix}\\]\n\\[C_A(\\nu) = \\begin{bmatrix} 0_{3 \\times 3} & -S(A_{11} v_1 + A_{12} v_2) \\\\\n-S(A_{11} v_1 + A_{12} v_2) & -S(A_{21} v_1 + A_{22} v_2) \\end{bmatrix}\\]\nWhere \\(v_1 = [u, v, w]^T\\) and \\(v_2 = [p, q, r]^T\\) are the linear and angular velocity components of \\(\\nu\\).\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ncalculate_coriolis_matrices(vel)\nComputes the rigid body and added mass Coriolis-centripetal matrices based on the current velocity state. Returns a tuple of \\((C_{RB}, C_A)\\) matrices.\n\n\n\n\n\nDamping Matrix\nThe damping matrix (\\(D(\\nu)\\)) represents hydrodynamic resistance forces and is typically modeled as:\n\\[D(\\nu) = D_{linear} + D_{nonlinear}(\\nu)\\]\nIn the implementation, damping is handled through hydrodynamic coefficients (entered in the hydrodynamics.yml input file) rather than an explicit matrix:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nhydrodynamic_forces(vel)\nComputes hydrodynamic damping forces by applying coefficients to velocity components. Supports linear, quadratic, and cross-terms.\n\n\ncross_flow_drag()\nEstimates sway-yaw damping coefficients for surface vessels using strip theory and Hoerner‚Äôs cross-flow drag.\n\n\ncross_flow_drag_AUV()\nSimilar to cross_flow_drag() but includes heave-pitch calculations for AUVs.\n\n\nhoerner()\nImplements Hoerner‚Äôs method for computing 2D drag coefficients based on section beam-to-draft ratio.\n\n\n\nThe coefficients follow a naming convention that indicates which force/moment they affect and which velocity components are involved (you can enter any custom hydrodynamic coefficients in the hydrodynamics.yml input file and it will be handled by the function for force calculations):\n\nLinear damping: X_u, Y_v, Z_w, K_p, M_q, N_r\nQuadratic damping: X_u_au, Y_v_av, Z_w_aw, etc. (the a indicates absolute value)\nCross-coupling: X_vr, Y_ur, N_uv, etc.\n\ndef hydrodynamic_forces(self, vel):\n    # Extract velocities\n    u, v, w, p, q, r = vel\n    \n    # Initialize forces vector\n    F = np.zeros(6)\n    \n    # Map velocity components to values\n    vel_map = {'u': u, 'v': v, 'w': w, 'p': p, 'q': q, 'r': r}\n    \n    # Process each hydrodynamic coefficient\n    for coeff_name, coeff_value in self.hydrodynamics.items():\n        if coeff_value == 0: continue\n        \n        parts = coeff_name.split('_')\n        force_dir = parts[0]\n        if force_dir not in self.force_indices: continue\n        \n        # Calculate force contribution\n        force = coeff_value\n        for component in parts[1:]:\n            if component.startswith('a') and len(component) &gt; 1:\n                # Absolute value term (e.g., u|u|)\n                v_char = component[1:]\n                force *= abs(vel_map[v_char])\n            elif component in vel_map:\n                # Regular term\n                force *= vel_map[component]\n                \n        # Add to force vector\n        F[self.force_indices[force_dir]] += force\n        \n    return F\n\n\nRestoring Forces\nThe restoring forces (\\(g(\\eta)\\)) include gravitational and buoyancy effects:\n\\[g(\\eta) = \\begin{bmatrix}\n(W - B) \\sin \\theta \\\\\n-(W - B) \\cos \\theta \\sin \\phi \\\\\n-(W - B) \\cos \\theta \\cos \\phi \\\\\n-(y_G W - y_B B) \\cos \\theta \\cos \\phi + (z_G W - z_B B) \\cos \\theta \\sin \\phi \\\\\n(z_G W - z_B B) \\sin \\theta + (x_G W - x_B B) \\cos \\theta \\cos \\phi \\\\\n-(x_G W - x_B B) \\cos \\theta \\sin \\phi - (y_G W - y_B B) \\sin \\theta\n\\end{bmatrix}\\]\nWhere:\n\n\\(W = mg\\) is the weight\n\\(B = \\rho g \\nabla\\) is the buoyancy force (with \\(\\nabla\\) being the displaced volume)\n\\(r_G = [x_G, y_G, z_G]^T\\) is the center of gravity mentioned in the geometry.yml input file\n\\(r_B = [x_B, y_B, z_B]^T\\) is the center of buoyancy mentioned in the geometry.yml input file\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ngravitational_forces(phi, theta)\nComputes the gravitational and buoyancy forces and moments as a function of roll and pitch angles.\n\n\n\n\n\nControl Forces\nThe control forces vector \\(\\tau\\) represents the combined effect of control surfaces and thrusters.#### Control Surface Forces\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ncontrol_forces(delta)\nCalculates forces and moments generated by control surfaces (rudders, fins, etc.) based on their deflection angles \\(\\delta\\). Supports both hydrodynamic coefficient-based and aerofoil-based calculation methods.\n\n\n\nFor hydrodynamic coefficient-based calculation: - Forces are calculated as \\(\\tau_i = C_{i\\delta} \\delta\\), where \\(C_{i\\delta}\\) is the control coefficient mentioned in the control_surface_hydrodynamics in the control_surfaces.yml input file\nFor aerofoil-based calculation:\n\nLocal velocity at the control surface is calculated considering vessel motion (automatically done)\nAngle of attack is determined from flow direction and surface deflection\nLift and drag forces are calculated using NACA airfoil data (path to the NACA file is mentioned in the control_surfaces.yml input file)\nForces are transformed to the body frame and a generalized force vector is returned\n\n\nThruster Forces\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nthruster_forces(n_prop)\nCalculates forces and moments from propellers/thrusters based on their rotational speeds \\(n\\) in RPM. Models thrust using propeller theory with advance ratio and thrust coefficients.\n\n\n\nThe thrust calculation follows the form: \\[X_{prop} = K_T \\rho D^4 |n| n\\]\nWhere:\n\n\\(K_T\\) is the thrust coefficient (approximated as \\(K_{T,J=0}(1-J)\\) with \\(J\\) being the advance ratio)\n\\(\\rho\\) is the water density\n\\(D\\) is the propeller diameter\n\\(n\\) is the propeller speed in revolutions per second",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "rawFiles/Dynamics/Dynamics.html#vessel-ode-and-simulation",
    "href": "rawFiles/Dynamics/Dynamics.html#vessel-ode-and-simulation",
    "title": "Dynamics",
    "section": "Vessel ODE and Simulation",
    "text": "Vessel ODE and Simulation\nThe vessel dynamics are implemented as an ordinary differential equation (ODE) in the vessel_ode(t, state) method, which computes the state derivatives:\ndef vessel_ode(self, t, state):\n    # Extract state components\n    vel = state[0:6]  # [u, v, w, p, q, r]\n    pos = state[6:9]  # [x, y, z]\n    angles = state[9:attitude_end]  # [phi, theta, psi] or quaternion\n    \n    # Calculate forces and moments\n    F_hyd = self.hydrodynamic_forces(vel)\n    F_control = self.control_forces(state[control_start:thruster_start])\n    F_thrust = self.thruster_forces(state[thruster_start:])\n    F_g = self.gravitational_forces(angles[0], angles[1])\n    \n    if self.coriolis_flag:\n        C_RB, C_A = self.calculate_coriolis_matrices(vel)\n        F_C = (C_RB + C_A) @ vel\n    else:\n        F_C = np.zeros(6)\n    \n    # Total force\n    F = F_hyd + F_control + F_thrust - F_g - F_C\n    \n    # Calculate velocity derivatives\n    M = self.mass_matrix + self.added_mass_matrix  # Total mass matrix\n    state_dot[0:6] = np.linalg.inv(M) @ F\n    \n    # Calculate position and attitude derivatives\n    # ...\n    \n    return state_dot\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nstep()\nAdvances the simulation by one time step by solving the ODE using SciPy‚Äôs solve_ivp.\n\n\nsimulate()\nRuns the full simulation by repeatedly calling step() until the final time.\n\n\nreset()\nResets the vessel to its initial state.",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "rawFiles/Dynamics/Dynamics.html#helper-methods-and-utilities",
    "href": "rawFiles/Dynamics/Dynamics.html#helper-methods-and-utilities",
    "title": "Dynamics",
    "section": "Helper Methods and Utilities",
    "text": "Helper Methods and Utilities\n\nDimensionalization\nHydrodynamic coefficients can be provided in non-dimensional form and converted to dimensional form:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\n_dimensionalize_coefficients(rho, L, U)\nConverts non-dimensional hydrodynamic coefficients to dimensional form based on density \\(\\rho\\), length \\(L\\), and characteristic velocity \\(U\\) (mentioned in the simulation_input.yml file)\n\n\n\n\n\nHydrodynamic Coefficient Calculation\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ncalculate_added_mass_from_hydra(hydra_file)\nCalculates the added mass matrix from HydRA data files.\n\n\ncross_flow_drag()\nEstimates sway-yaw hydrodynamic coefficients using strip theory.\n\n\ncross_flow_drag_AUV()\nEstimates both sway-yaw and heave-pitch coefficients for underwater vehicles.\n\n\nhoerner()\nImplements Hoerner‚Äôs method for 2D section drag coefficient calculation.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nUnderstanding these dynamics components is essential for correctly configuring vessel parameters and interpreting simulation results. The implementation allows for flexible modeling of different vessel types by adjusting the parameters and coefficients.",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html",
    "href": "rawFiles/Navigation/sensors.html",
    "title": "Sensors Simulation",
    "section": "",
    "text": "Overview\nThe Panisim simulator provides realistic sensor simulations to enable the development and testing of perception, estimation, and control algorithms. The sensor system is designed to be:\nThis document explains how sensors are simulated, configured, and how you can create your own custom sensors.",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html#overview",
    "href": "rawFiles/Navigation/sensors.html#overview",
    "title": "Sensors Simulation",
    "section": "",
    "text": "Modular: Each sensor is implemented as a separate class\nConfigurable: Sensors can be customized through YAML configuration files\nRealistic: Includes appropriate noise models and physical placement effects\nExtensible: New sensor types can be easily added",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html#sensor-architecture",
    "href": "rawFiles/Navigation/sensors.html#sensor-architecture",
    "title": "Sensors Simulation",
    "section": "Sensor Architecture",
    "text": "Sensor Architecture\nAll sensors in the simulator inherit from a common BaseSensor class that handles basic functionality such as:\n\nSensor identification and topic naming\nUpdate rate management\nAccess to vessel state\nNoise and covariance management\n\nThe sensor architecture follows this class hierarchy:\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff' }}}%%\nclassDiagram\n    BaseSensor &lt;|-- IMUSensor\n    BaseSensor &lt;|-- GPSSensor\n    BaseSensor &lt;|-- UWBSensor\n    BaseSensor &lt;|-- EncoderSensor\n    BaseSensor &lt;|-- DVLSensor\n    BaseSensor &lt;|-- CustomSensor\n    \n    class BaseSensor {\n        +vessel_id\n        +topic_prefix\n        +sensor_type\n        +rate\n        +topic\n        +id\n        +vessel_node\n        +use_custom_covariance\n        +custom_covariance\n    }\n    \n    class IMUSensor {\n        +location\n        +orientation\n        +get_measurement()\n    }\n    \n    class GPSSensor {\n        +location\n        +get_measurement()\n    }\n    \n    class UWBSensor {\n        +location\n        +get_measurement()\n    }\n    \n    class EncoderSensor {\n        +actuator_type\n        +actuator_id\n        +get_measurement()\n    }\n    \n    class DVLSensor {\n        +location\n        +orientation\n        +get_measurement()\n    }\n    \n    class CustomSensor {\n        +custom_properties\n        +get_measurement()\n    }",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html#sensor-types-and-simulation",
    "href": "rawFiles/Navigation/sensors.html#sensor-types-and-simulation",
    "title": "Sensors Simulation",
    "section": "Sensor Types and Simulation",
    "text": "Sensor Types and Simulation\nThe simulator currently supports the following sensor types:\n\nIMU (Inertial Measurement Unit)\nIMU sensors measure: - Orientation (quaternion) - Angular velocity (rad/s) - Linear acceleration (m/s¬≤)\nSimulation details:\nThe IMU simulation accounts for:\n\nSensor placement relative to the vessel‚Äôs center of mass\nSensor orientation relative to the vessel‚Äôs body frame\nGravitational acceleration effects\nCentripetal and tangential accelerations due to vessel rotation\nRealistic noise models for all measurements\n\nNoise model:\n\nOrientation: Multivariate normal distribution applied to Euler angles\nAngular velocity: Multivariate normal distribution\nLinear acceleration: Multivariate normal distribution\n\nThe covariances are defined in the sensors.yml file.\n# Example of how IMU measurements are generated\ndef get_measurement(self, quat=False):\n    state = self.vessel_node.vessel.current_state\n    state_der = self.vessel_node.vessel.current_state_der\n    \n    # Convert orientation and add noise\n    q_sensor = kin.rotm_to_quat(kin.quat_to_rotm(quat) @ kin.quat_to_rotm(orientation_quat))\n    q_sensor = kin.eul_to_quat(kin.quat_to_eul(q_sensor) + np.random.multivariate_normal(np.zeros(3), self.eul_cov))\n    \n    # Calculate acceleration including all effects\n    acc_bcs = state_der[0:3] + np.cross(omg_bcs, v_bcs)\n    acc_s_bcs = acc_bcs + np.cross(alpha, self.location) + np.cross(omg_bcs, np.cross(omg_bcs, self.location))\n    acc_sensor = kin.quat_to_rotm(orientation_quat).T @ acc_s_bcs\n    \n    # Add gravity and noise\n    acc_sensor = acc_sensor + kin.quat_to_rotm(q_sensor).T @ np.array([0, 0, -self.vessel_node.vessel.g])\n    acc_sensor = acc_sensor + np.random.multivariate_normal(np.zeros(3), self.lin_acc_cov)\n\n    # Calculate angular velocity with noise\n    omg_sensor = kin.quat_to_rotm(orientation_quat).T @ omg_bcs\n    omg_sensor = omg_sensor + np.random.multivariate_normal(np.zeros(3), self.ang_vel_cov)\n\n    return {...}  # Return measurements and covariances\n\n\nGPS (Global Positioning System)\nGPS sensors measure:\n\nLatitude (degrees)\nLongitude (degrees)\nAltitude (meters)\n\nSimulation details:\nThe GPS simulation accounts for:\n\nSensor placement on the vessel\nConversion between NED (North-East-Down) and LLH (Latitude-Longitude-Height) coordinates\nRealistic position noise\n\nNoise model:\n\nPosition: Multivariate normal distribution applied to NED coordinates before conversion to LLH\n\n# Example of how GPS measurements are generated\ndef get_measurement(self, quat=False):\n    state = self.vessel_node.vessel.current_state\n    llh0 = self.vessel_node.vessel.gps_datum\n    \n    # Get position in NED, add sensor offset and noise\n    ned = state[6:9] + kin.quat_to_rotm(orientation) @ self.location\n    ned = ned + np.random.multivariate_normal(np.zeros(3), self.gps_cov)\n    \n    # Convert to latitude-longitude-height\n    llh = kin.ned_to_llh(ned, llh0)\n\n    return {...}  # Return latitude, longitude, altitude and covariance\n\n\nUWB (Ultra-Wideband Positioning)\nUWB sensors measure: - Position in the NED frame (meters)\nSimulation details:\nThe UWB simulation accounts for:\n\nSensor placement on the vessel\nPosition in the NED coordinate frame\nRealistic position noise (typically higher precision than GPS)\n\nNoise model:\n\nPosition: Multivariate normal distribution applied to NED coordinates\n\n# Example of how UWB measurements are generated\ndef get_measurement(self, quat=False):\n    state = self.vessel_node.vessel.current_state\n    ned = state[6:9]\n    \n    # Get position and add sensor offset and noise\n    r_sen = ned + kin.quat_to_rotm(orientation) @ self.location\n    r_sen = r_sen + np.random.multivariate_normal(np.zeros(3), self.uwb_cov)\n\n    return {...}  # Return position and covariance\n\n\nEncoder Sensors\nEncoder sensors measure:\n\nActuator position (degrees for control surfaces, RPM for thrusters)\n\nSimulation details:\nThe encoder simulation accounts for:\n\nSpecific actuator type (rudder, thruster, etc.)\nUnit conversion from state vector to appropriate units\nActuator-specific noise characteristics\n\nNoise model:\n\nActuator value: Normal distribution with specified RMS noise\n\n# Example of how Encoder measurements are generated\ndef get_measurement(self):\n    state = self.vessel_node.vessel.current_state\n    \n    # Get the specific actuator value from the state vector\n    actuator_value_raw = state[self.state_index]\n    \n    # Apply unit conversion (e.g., rad to degrees, rad/s to RPM)\n    actuator_value_converted = actuator_value_raw * self.unit_conversion\n    \n    # Add noise to the converted measurement\n    actuator_value_noisy = actuator_value_converted + np.random.normal(0, self.noise_rms)\n\n    return {...}  # Return actuator value, name, and covariance\n\n\nDVL (Doppler Velocity Log)\nDVL sensors measure:\n\nLinear velocity in the body frame (m/s)\n\nSimulation details:\nThe DVL simulation accounts for:\n\nSensor placement and orientation\nBody-frame velocity measurements\nRealistic velocity noise\n\nNoise model:\n\nVelocity: Multivariate normal distribution applied to body-frame velocity\n\n# Example of how DVL measurements are generated\ndef get_measurement(self, quat=False):\n    state = self.vessel_node.vessel.current_state\n    \n    # Get body-frame velocity and add noise\n    v_body = state[0:3]\n    v_body_noisy = v_body + np.random.multivariate_normal(np.zeros(3), self.vel_cov)\n    \n    return {...}  # Return velocity and covariance",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html#sensor-configuration",
    "href": "rawFiles/Navigation/sensors.html#sensor-configuration",
    "title": "Sensors Simulation",
    "section": "Sensor Configuration",
    "text": "Sensor Configuration\nSensors are configured through the YAML configuration files. Each sensor definition includes:\n\nsensor_type: The type of sensor (IMU, GPS, UWB, encoder, DVL)\nsensor_topic: ROS topic for publishing sensor data\nsensor_location: Position of the sensor in the body frame [x, y, z]\nsensor_orientation: Orientation of the sensor in the body frame [roll, pitch, yaw]\npublish_rate: Update frequency in Hz\nuse_custom_covariance: Boolean flag to use custom noise parameters\ncustom_covariance: Custom noise covariance matrices for each measurement\n\nExample configuration for an IMU sensor:\nsensors:\n  - \n    sensor_type: IMU\n    sensor_topic: /vessel_01/imu/data\n    sensor_location: [0.0, 0.0, 0.1]\n    sensor_orientation: [0.0, 0.0, 0.0]\n    publish_rate: 100\n    use_custom_covariance: true\n    custom_covariance:\n      orientation_covariance: [0.001, 0.0, 0.0, 0.0, 0.001, 0.0, 0.0, 0.0, 0.001]\n      angular_velocity_covariance: [0.0001, 0.0, 0.0, 0.0, 0.0001, 0.0, 0.0, 0.0, 0.0001]\n      linear_acceleration_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html#creating-custom-sensors",
    "href": "rawFiles/Navigation/sensors.html#creating-custom-sensors",
    "title": "Sensors Simulation",
    "section": "Creating Custom Sensors",
    "text": "Creating Custom Sensors\nTo create your own custom sensor, follow these steps:\n\n1. Create a new sensor class\nCreate a new class that inherits from BaseSensor and implements the get_measurement() method:\nclass CustomSensor(BaseSensor):\n    def __init__(self, sensor_config, vessel_id, topic_prefix, vessel_node):\n        super().__init__(sensor_config, vessel_id, topic_prefix, vessel_node)\n        # Initialize sensor-specific properties\n        self.location = np.array(sensor_config['sensor_location'])\n        self.custom_param = sensor_config.get('custom_param', default_value)\n        \n        # Initialize noise parameters\n        self.custom_rms = np.array([0.1, 0.1, 0.1])\n        self.custom_cov = np.diag(self.custom_rms ** 2)\n        \n        # Override with custom covariance if provided\n        if self.use_custom_covariance and self.custom_covariance:\n            if 'custom_measurement_covariance' in self.custom_covariance:\n                self.custom_cov = np.array(self.custom_covariance['custom_measurement_covariance']).reshape(3, 3)\n\n    def get_measurement(self, quat=False):\n        # Access vessel state\n        state = self.vessel_node.vessel.current_state\n        \n        # Generate realistic measurements based on state\n        # Apply appropriate transformations, physics models, etc.\n        \n        # Add noise to measurements\n        measurement = calculated_value + np.random.multivariate_normal(np.zeros(3), self.custom_cov)\n        \n        # Return measurement as a dictionary\n        return {\n            'custom_measurement': measurement,\n            'covariance': self.custom_cov.flatten()\n        }\n\n\n2. Register your sensor in the factory function\nModify the create_sensor function to include your new sensor type:\ndef create_sensor(sensor_config, vessel_id, topic_prefix, vessel_node):\n    \"\"\"Factory function to create appropriate sensor object based on sensor type\"\"\"\n    sensor_type = sensor_config['sensor_type']\n    sensor_classes = {\n        'IMU': IMUSensor,\n        'GPS': GPSSensor,\n        'UWB': UWBSensor,\n        'encoder': EncoderSensor,\n        'DVL': DVLSensor,\n        'CustomSensor': CustomSensor  # Add your custom sensor here\n    }\n    \n    if sensor_type not in sensor_classes:\n        raise ValueError(f\"Unknown sensor type: {sensor_type}\")\n        \n    return sensor_classes[sensor_type](sensor_config, vessel_id, topic_prefix, vessel_node)\n\n\n3. Create a ROS publisher for your custom sensor\nIn your vessel‚Äôs ROS node, add a publisher for your custom sensor:\n# In the vessel ROS node initialization\nif sensor.sensor_type == 'CustomSensor':\n    # Create a publisher for your custom sensor\n    # Choose an appropriate message type or create a custom one\n    from your_package.msg import CustomSensorMsg\n    \n    publisher = self.create_publisher(\n        CustomSensorMsg,\n        f'{self.topic_prefix}/{sensor.topic}',\n        10\n    )\n    \n    # Add the publisher to the sensor publishers dictionary\n    self.sensor_publishers[sensor] = publisher\n    \n# In the vessel ROS node update method\nif sensor.sensor_type == 'CustomSensor':\n    # Create a message for your custom sensor\n    msg = CustomSensorMsg()\n    \n    # Fill the message with sensor data\n    measurement = sensor.get_measurement()\n    msg.data = measurement['custom_measurement']\n    msg.covariance = measurement['covariance']\n    \n    # Add a timestamp\n    msg.header.stamp = self.get_clock().now().to_msg()\n    \n    # Publish the message\n    self.sensor_publishers[sensor].publish(msg)\n\n\n4. Configure your custom sensor in the YAML file\nAdd your custom sensor to the sensors configuration file:\nsensors:\n  - \n    sensor_type: CustomSensor\n    sensor_topic: /vessel_01/custom_sensor\n    sensor_location: [0.1, 0.0, 0.2]\n    sensor_orientation: [0.0, 0.0, 0.0]\n    publish_rate: 50\n    custom_param: 42.0\n    use_custom_covariance: true\n    custom_covariance:\n      custom_measurement_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Navigation/sensors.html#best-practices-for-sensor-simulation",
    "href": "rawFiles/Navigation/sensors.html#best-practices-for-sensor-simulation",
    "title": "Sensors Simulation",
    "section": "Best Practices for Sensor Simulation",
    "text": "Best Practices for Sensor Simulation\nWhen working with sensors in the simulator, follow these guidelines:\n\nPhysical realism:\n\nPlace sensors at realistic positions on the vessel\nUse realistic noise parameters based on actual sensor specifications\nConsider environmental effects if appropriate (e.g., GPS degradation underwater)\n\nComputational efficiency:\n\nSet appropriate update rates based on real-world sensors\nUse optimized noise generation methods for high-frequency sensors\n\nSensor fusion testing:\n\nConfigure multiple sensor types to test fusion algorithms\nVary noise parameters to test robustness of estimation algorithms\n\nCustom sensors:\n\nFollow the class structure of existing sensors\nDocument physical models and assumptions clearly\nUse appropriate coordinate transformations\n\nTopic naming:\n\nUse consistent naming conventions for sensors\nInclude vessel ID in topic names for multi-vessel simulations",
    "crumbs": [
      "Sensors Simulation"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html",
    "href": "rawFiles/Inputs/inputs.html",
    "title": "Simualtion Inputs",
    "section": "",
    "text": "Overview\nThe Panisim simulator uses a structured set of YAML configuration files to define all aspects of the simulation environment, vessel properties, sensor configurations and guidance. This modular approach allows for easy customization and extension of simulation scenarios without modifying the core simulation code. The input files are auto generated via the interactive Web GUI, but can also be modified manually.",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#overview",
    "href": "rawFiles/Inputs/inputs.html#overview",
    "title": "Simualtion Inputs",
    "section": "",
    "text": "Tip\n\n\n\nAll input files follow the YAML format, which is human-readable and easy to edit.",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#input-file-structure",
    "href": "rawFiles/Inputs/inputs.html#input-file-structure",
    "title": "Simualtion Inputs",
    "section": "Input File Structure",
    "text": "Input File Structure\nThe input file system follows a hierarchical structure (zoom in to see the chart more clearly).\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nflowchart TD\n    classDef main fill:#FF6347,stroke:#8B3626,color:white,font-size:14px;\n    classDef folder fill:#5D8AA8,stroke:#1F456E,color:white,font-size:14px;\n    classDef file fill:#6B8E23,stroke:#2E3B0F,color:white,font-size:12px;\n    \n    SimInput[\"simulation_input.yml\"] --&gt; VesselFolder1[\"Vessel Folder (e.g., sookshma)\"]\n    SimInput --&gt; VesselFolder2[\"Vessel Folder (e.g., mavymini)\"]\n    \n    VesselFolder1 --&gt; Geometry1[\"geometry.yml\"]\n    VesselFolder1 --&gt; Inertia1[\"inertia.yml\"]\n    VesselFolder1 --&gt; Hydro1[\"hydrodynamics.yml\"]\n    VesselFolder1 --&gt; InitCond1[\"initial_conditions.yml\"]\n    VesselFolder1 --&gt; Control1[\"control_surfaces.yml\"]\n    VesselFolder1 --&gt; Thrusters1[\"thrusters.yml\"]\n    VesselFolder1 --&gt; Sensors1[\"sensors.yml\"]\n    VesselFolder1 --&gt; Guidance1[\"guidance.yml\"]\n    VesselFolder1 --&gt; Control1a[\"control.yml\"]\n    \n    VesselFolder2 --&gt; Geometry2[\"geometry.yml\"]\n    VesselFolder2 --&gt; Inertia2[\"inertia.yml\"]\n    VesselFolder2 --&gt; Hydro2[\"hydrodynamics.yml\"]\n    VesselFolder2 --&gt; InitCond2[\"initial_conditions.yml\"]\n    VesselFolder2 --&gt; Control2[\"control_surfaces.yml\"]\n    VesselFolder2 --&gt; Thrusters2[\"thrusters.yml\"]\n    VesselFolder2 --&gt; Sensors2[\"sensors.yml\"]\n    VesselFolder2 --&gt; Guidance2[\"guidance.yml\"]\n    VesselFolder2 --&gt; Control2a[\"control.yml\"]\n    \n    class SimInput main;\n    class VesselFolder1,VesselFolder2 folder;\n    class Geometry1,Inertia1,Hydro1,InitCond1,Control1,Thrusters1,Sensors1,Guidance1,Control1a,Geometry2,Inertia2,Hydro2,InitCond2,Control2,Thrusters2,Sensors2,Guidance2,Control2a file;\n\n\n\n\n\n\nThe top-level simulation_input.yml file defines global simulation parameters and references vessel-specific configuration files stored in separate folders (one for each vessel type).",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#main-configuration-file",
    "href": "rawFiles/Inputs/inputs.html#main-configuration-file",
    "title": "Simualtion Inputs",
    "section": "Main Configuration File",
    "text": "Main Configuration File\nThe simulation_input.yml file is the entry point for the simulator configuration. It specifies global parameters and the list of agents (vessels) to include in the simulation.\nExample structure:\nsim_time: 100.0               # Total simulation time in seconds\ntime_step: 0.01               # Simulation time step in seconds\ndensity: 1025.0               # Water density (kg/m¬≥)\ngravity: 9.80665              # Gravitational acceleration (m/s¬≤)\nworld_size: [1000, 1000, 100] # Simulation world dimensions [x, y, z] in meters\ngps_datum: [13.06, 80.28, 0]  # GPS reference point [latitude, longitude, height]\nnagents: 1                    # Number of agents in the simulation\ngeofence: []                  # Optional geofencing boundaries\n\nagents:\n  - name: \"sookshma\"          # Vessel name\n    type: \"usv\"               # Vessel type (usv, auv, etc.)\n    active_dof: [1, 1, 0, 0, 0, 1]  # Active degrees of freedom [u, v, w, p, q, r]\n    U: 0.0                    # Initial forward speed\n    maintain_speed: false     # Whether to maintain constant forward speed\n    \n    # Paths to configuration files (relative or absolute)\n    # {name} will be replaced with the vessel name\n    geometry: \"inputs/{name}/geometry.yml\"\n    inertia: \"inputs/{name}/inertia.yml\"\n    hydrodynamics: \"inputs/{name}/hydrodynamics.yml\"\n    control_surfaces: \"inputs/{name}/control_surfaces.yml\"\n    thrusters: \"inputs/{name}/thrusters.yml\"\n    initial_conditions: \"inputs/{name}/initial_conditions.yml\"\n    sensors: \"inputs/{name}/sensors.yml\"\n    guidance: \"inputs/{name}/guidance.yml\"\n    control: \"inputs/{name}/control.yml\"\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nsim_time\nTotal simulation duration\nseconds\n\n\ntime_step\nSimulation time step size\nseconds\n\n\ndensity\nWater density\nkg/m¬≥\n\n\ngravity\nGravitational acceleration\nm/s¬≤\n\n\nworld_size\nSimulation world dimensions [x, y, z]\nmeters\n\n\ngps_datum\nReference point for GPS coordinates [lat, lon, height]\ndegrees, degrees, meters\n\n\nnagents\nNumber of agents (vessels) in the simulation\ninteger\n\n\ngeofence\nOptional boundaries for the simulation area\nmeters\n\n\n\n\n\nAgent Configuration\nEach agent (vessel) in the agents list requires:\n\nname: Identifier for the vessel, used for file path resolution\ntype: Type of vessel (‚Äúusv‚Äù, ‚Äúauv‚Äù, etc.)\nactive_dof: Array of 6 binary values indicating which degrees of freedom are active [surge, sway, heave, roll, pitch, yaw]\nU: Initial/desired forward speed\nmaintain_speed: Boolean flag to maintain constant forward speed\n\nFile paths can be absolute or relative (although we would recommend using the same folder structure as the default). The special placeholder {name} will be replaced with the vessel name, allowing for a standardized folder structure.",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#vessel-specific-configuration-files",
    "href": "rawFiles/Inputs/inputs.html#vessel-specific-configuration-files",
    "title": "Simualtion Inputs",
    "section": "Vessel-Specific Configuration Files",
    "text": "Vessel-Specific Configuration Files\nEach vessel has its own set of configuration files that define its physical properties, sensors, and control elements. This is defined in a folder named after the vessel.\n\nGeometry Configuration (geometry.yml)\nThe geometry file defines the vessel‚Äôs physical dimensions and coordinate frames.\nExample from sookshma:\n# Dimensions of the box enclosing the vessel\nlength: 1\nbreadth: 0.24\ndepth: 0.5\nFn: 0.16\ngyration: [0.096, 0.25, 0.25]\nCO:\n  position: [0.0, 0.0, 0.0] # Relative to the origin of the 3d software\n  orientation: [0.0, 0.0, 0.0]\nCG:\n  position: [2.89415958e-02, 0.0, 1.62558889e-01]\nCB:\n  position: [2.89415958e-02, 0.0, 1.36000000e-01]\n  \ngeometry_file: /workspaces/mavlab/inputs/sookshma/HydRA/input/sookshma.gdf\n\nKey Parameters\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nlength\nOverall length\nmeters\n\n\nbreadth\nOverall width\nmeters\n\n\ndepth\nOverall depth\nmeters\n\n\nFn\nFroude number\ndimensionless\n\n\ngyration\nGyration radii [x, y, z]\nmeters\n\n\nCO\nCoordinate origin position and orientation\nmeters, radians\n\n\nCG\nCenter of gravity position and orientation\nmeters, radians\n\n\nCB\nCenter of buoyancy position and orientation\nmeters, radians\n\n\ngeometry_file\nPath to 3D geometry file\nstring\n\n\n\n\n\n\nInertia Configuration (inertia.yml)\nThe inertia file defines the vessel‚Äôs mass properties.\nExample from sookshma:\nmass: 7.65 # in kg\nbuoyancy_mass: 7.65 # in kg\ninertia_matrix: None # in kg*m^2\nadded_mass_matrix: None # in kg*m^2/s\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nmass\nVessel mass\nkg\n\n\nbuoyancy_mass\nMass of displaced fluid (for neutral buoyancy, equal to mass)\nkg\n\n\ninertia_matrix\nOptional explicit inertia matrix needs to be 6x6 (example: [[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]])\nkg¬∑m¬≤\n\n\nadded_mass_matrix\nOptional explicit added mass matrix needs to be 6x6\nkg, kg¬∑m¬≤, kg¬∑m\n\n\n\nIf the inertia matrix is not provided, it is calculated using the gyration radii and the mass via the _generate_mass_matrix() function in the calculate_hydrodynamics.py module. If the added mass matrix is not provided, it will be calculated either using the hydrodynamic derivatives or using the hydrodynamic coefficients from the HydRA model.\n\n\n\nHydrodynamics Configuration (hydrodynamics.yml)\nThe hydrodynamics file contains coefficients for damping forces and added mass.\nExample from sookshma:\nhydra_file: /workspaces/mavlab/inputs/sookshma/HydRA/matlab/sookshma_hydra.json\ndim_flag: false\ncross_flow_drag: false\ncoriolis_flag: false # For linear dynamic model\n\n# Surge hydrodynamic derivatives\nX_u: -0.01\n\n# Sway hydrodynamic derivatives\nY_v: -0.010659050686665396\nY_r: 0.0017799664706713543\n\n# Yaw hydrodynamic derivatives\nN_v: -0.0006242757399292063\nN_r: -0.001889456681929024\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nhydra_file\nPath to HydRA data file\nstring\n\n\ndim_flag\nWhether coefficients are dimensional (true) or non-dimensional (false)\nboolean\n\n\ncross_flow_drag\nWhether to use cross-flow drag calculation\nboolean\n\n\ncoriolis_flag\nWhether to include Coriolis forces\nboolean\n\n\n\nYou can enter any combination of the hydrodynamic coefficients, and it‚Äôll be handled by the simulator. They should be separated by underscores. For example, X_u_u or M_r_r.\n\n\n\nControl Surfaces Configuration (control_surfaces.yml)\nThis file defines the vessel‚Äôs control surfaces such as rudders, fins, or foils.\nExample from sookshma:\nnaca_number: &naca None\nnaca_file: &naca_file None\ndelta_max: &dmax 35.0\ndeltad_max: &ddmax 1.0\narea: &area 0.1 \n\ncontrol_surfaces:\n  - \n    control_surface_type: Rudder\n    control_surface_id: 1\n    control_surface_location: [0.0, 0.0, 0.0]    # With respect to BODY frame\n    control_surface_orientation: [0.0, 0.0, 0.0]  # With respect to BODY frame\n    control_surface_area: *area\n    control_surface_NACA: *naca\n    control_surface_T: 0.1\n    control_surface_delta_max: *dmax\n    control_surface_deltad_max: *ddmax\n    control_surface_hydrodynamics:\n      Y_delta: 0.02100751285923063\n      N_delta: -0.006813248905845932\n      X_delta: 0.0\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nnaca_number\nNACA airfoil designation\nstring\n\n\nnaca_file\nPath to NACA airfoil data file\nstring\n\n\ndelta_max\nMaximum deflection angle\ndegrees\n\n\ndeltad_max\nMaximum deflection rate\ndegrees/s\n\n\narea\nSurface area\nm¬≤\n\n\ncontrol_surface_type\nType of control surface (e.g., Rudder, Fin)\nstring\n\n\ncontrol_surface_id\nUnique identifier\ninteger\n\n\ncontrol_surface_location\n[x, y, z] position\nmeters\n\n\ncontrol_surface_orientation\n[roll, pitch, yaw] orientation\nradians\n\n\ncontrol_surface_T\nActuation time constant\nseconds\n\n\ncontrol_surface_hydrodynamics\nForce coefficients for the control surface\nvarious\n\n\n\nIf control_surface_hydrodynamics is provided, the control surface location, orientation and naca file will be ignored. And the generalized force vector due to control surface will be calculated using the hydrodynamic coefficients.\n\n\n\nThruster Configuration (thrusters.yml)\nThis file defines the vessel‚Äôs propulsion systems.\nExample from sookshma (commented out):\n thrusters: \n   - \n     thruster_name: back\n     thruster_id: 1\n     thruster_location: [0.0, 0.0, 0.0]    # With respect to BODY frame\n     thruster_orientation: [0.0, 0.0, 0.0]  # With respect to BODY frame\n     T_prop: 1.0\n     D_prop: 0.1\n     tp: 0.1\n     KT_at_J0: 0.0 \n     n_max: 2668 # in RPM\n     J_vs_KT: None # File path to J_vs_KT.csv, Not being used currently\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nthruster_name\nDescriptive name\nstring\n\n\nthruster_id\nUnique identifier\ninteger\n\n\nthruster_location\n[x, y, z] position\nmeters\n\n\nthruster_orientation\n[roll, pitch, yaw] orientation\nradians\n\n\nT_prop\nPropeller thrust coefficient\ndimensionless\n\n\nD_prop\nPropeller diameter\nmeters\n\n\ntp\nThrust deduction coefficient\ndimensionless\n\n\nKT_at_J0\nThrust coefficient at zero advance ratio\ndimensionless\n\n\nn_max\nMaximum RPM\nRPM\n\n\nJ_vs_KT\nPath to file with advance ratio vs thrust coefficient data\nstring\n\n\n\n\n\n\nInitial Conditions Configuration (initial_conditions.yml)\nThis file defines the vessel‚Äôs initial state for the simulation.\nExample from sookshma:\nstart_location: [0, 0, 0]\nstart_orientation: [0, 0, 0]\nstart_velocity: [0.5, 0, 0, 0, 0, 0]\nuse_quaternion: false\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nstart_location\nInitial [x, y, z] position\nmeters\n\n\nstart_orientation\nInitial [roll, pitch, yaw] orientation\nradians\n\n\nstart_velocity\nInitial [u, v, w, p, q, r] velocity\nm/s, rad/s\n\n\nuse_quaternion\nWhether to use quaternions for orientation\nboolean\n\n\n\n\n\n\nSensors Configuration (sensors.yml)\nThis file defines the sensors attached to the vessel.\nExample from sookshma:\n# Custom covariance flag is applicable only when using GNC\n\nsensors:\n  - \n    sensor_type: IMU\n    sensor_topic: /sookshma_00/imu/data\n    sensor_location: [0.0, 0.0, 0.0]          \n    sensor_orientation: [0.0, 0.0, 0.0]\n    publish_rate: 50        \n    use_custom_covariance: true\n    custom_covariance:\n      orientation_covariance: [4.97116638e-07, 1.92100383e-07, -5.37921803e-06, 1.92100383e-07, 4.19220441e-07, -2.48717925e-06, -5.37921803e-06, -2.48717925e-06, 1.15176790e-04]\n      linear_acceleration_covariance: [0.01973958, -0.01976063, 0.02346221, -0.01976063, 0.0211394, -0.02188356, 0.02346221, -0.02188356, 0.03132967]\n      angular_velocity_covariance: [5.28022053e-05, 4.08840955e-05, -1.15368805e-05, 4.08840955e-05, 3.58062060e-05, -8.83069166e-06, -1.15368805e-05, -8.83069166e-06, 5.01080310e-06]\n  \n  -\n    sensor_type: UWB\n    sensor_topic: /sookshma_00/uwb\n    sensor_location: [0.0, 0.0, 0.0]\n    sensor_orientation: [0.0, 0.0, 0.0]   \n    publish_rate: 1\n    use_custom_covariance: true\n    custom_covariance:\n      position_covariance: [0.04533883, -0.05014115, 0.0, -0.05014115, 0.05869406, 0.0, 0.0, 0.0, 0.00000001]\n    \n  -\n    sensor_type: encoder\n    actuator_type: Rudder\n    actuator_id: 1\n    sensor_topic: /sookshma_00/Rudder_1/encoder\n    publish_rate: 10\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nsensor_type\nType of sensor (IMU, GPS, UWB, DVL, encoder, etc.)\nstring\n\n\nsensor_topic\nROS topic for publishing sensor data\nstring\n\n\nsensor_location\n[x, y, z] position\nmeters\n\n\nsensor_orientation\n[roll, pitch, yaw] orientation\nradians\n\n\npublish_rate\nData publication frequency\nHz\n\n\nuse_custom_covariance\nWhether to use custom noise covariance\nboolean\n\n\ncustom_covariance\nSensor-specific covariance matrices\nvarious\n\n\nactuator_type\nFor encoders, the type of actuator\nstring\n\n\nactuator_id\nFor encoders, the ID of the actuator\ninteger\n\n\n\n\n\n\nGuidance Configuration (guidance.yml)\nThis file defines waypoints and guidance parameters for autonomous navigation as used in the PID Waypoint Tracking Example.\nExample from sookshma:\nwaypoints:\n- [0, 0, 0]\n- [-4, -10, 0]\n- [8, -5, 0]\n- [9, 9, 0]\n- [0, 0, 0]\nwaypoints_type: XYZ\n\nKey Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\nUnits\n\n\n\n\nwaypoints\nList of waypoint coordinates\nmeters\n\n\nwaypoints_type\nCoordinate system for waypoints (XYZ, LLA, NED)\nstring\n\n\nlookahead_distance\nOptional: Distance for lookahead-based guidance\nmeters\n\n\nacceptance_radius\nOptional: Radius to consider waypoint reached\nmeters\n\n\nguidance_type\nOptional: Type of guidance algorithm\nstring\n\n\n\n\n\n\nNACA Airfoil Data (example: NACA0015.csv)\nThis file contains aerodynamic/hydrodynamic coefficients for the NACA0015 airfoil profile, used for modeling control surfaces like rudders. The file includes:\n\nAlpha: Angle of attack in degrees\nCl: Lift coefficient\nCd: Drag coefficient\nCdp: Pressure drag coefficient\nCm: Pitching moment coefficient\nTop_Xtr: Top surface transition location\nBot_Xtr: Bottom surface transition location\n\nSample excerpt:\nAlpha,Cl,Cd,Cdp,Cm,Top_Xtr,Bot_Xtr\n-19.750,-1.2970,0.09858,0.09490,-0.0142,1.0000,0.0253\n-19.500,-1.3072,0.09342,0.08964,-0.0166,1.0000,0.0255\n...\n0.000,0.0000,0.00632,0.00147,0.0000,0.6107,0.6107\n...\n19.750,1.2970,0.09858,0.09490,0.0142,0.0253,1.0000\nThis data is used to calculate the forces and moments generated by control surfaces at different angles of attack. This file is obtained from Airfoil Tools website.",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#input-file-processing",
    "href": "rawFiles/Inputs/inputs.html#input-file-processing",
    "title": "Simualtion Inputs",
    "section": "Input File Processing",
    "text": "Input File Processing\nThe read_input.py module is responsible for loading and processing all input files. The main function is read_input(), which:\n\nLoads the main simulation configuration file\nExtracts global simulation parameters\nProcesses each vessel‚Äôs configuration files\nTransforms component positions and orientations to be relative to the vessel‚Äôs coordinate origin (CO)\nReturns the processed simulation parameters and agent configurations\n\n\nKey Functions\n\nread_input(input_file)\nThe main entry point that reads the entire configuration:\ndef read_input(input_file: str = None) -&gt; Tuple[Dict, List[Dict]]:\n    \"\"\"Read vessel parameters and configuration from input files.\n    \n    Args:\n        input_file: Path to the main simulation input file. If None, uses default.\n        \n    Returns:\n        Tuple containing:\n            sim_params (Dict): Global simulation parameters\n            agents (List[Dict]): List of agents, each containing vessel config and hydrodynamics\n    \"\"\"\n\n\nload_yaml(file_path)\nLoads a YAML file and returns its contents:\ndef load_yaml(file_path: str) -&gt; Dict:\n    \"\"\"Load a YAML file and return its contents.\"\"\"\n    with open(file_path, 'r') as file:\n        return yaml.safe_load(file)\n\n\nresolve_path(base_path, file_path, name)\nResolves file paths, replacing {name} with the actual vessel name:\ndef resolve_path(base_path: str, file_path: str, name: str) -&gt; str:\n    \"\"\"Resolve a file path, replacing {name} with the actual vessel name.\"\"\"\n    resolved = file_path.replace('{name}', name)\n    if not os.path.isabs(resolved):\n        resolved = os.path.join(base_path, resolved)\n    return resolved\n\n\ntransform_to_co_frame(vessel_config)\nTransforms all component positions and orientations to be relative to the vessel‚Äôs coordinate origin (CO):\ndef transform_to_co_frame(vessel_config: Dict) -&gt; Dict:\n    \"\"\"Transform all component positions and orientations to be relative to the CO frame.\"\"\"\n    # Implementation details...\n\n\n\nCross-Flow Drag Generation\nThe read_input function also initializes a CrossFlowGenerator to calculate cross-flow drag coefficients:\ncross_flow_generator = CrossFlowGenerator(gdf_file, hydra_file, hydrodynamics_file, \n                                         initial_conditions_file, agent['type'])\ncross_flow_generator.update_yaml_file()\nThis automatically computes and updates the hydrodynamic coefficients for sway-yaw (and heave-pitch for AUVs) using strip theory and Hoerner‚Äôs cross-flow drag formulation. This happens if the cross_flow_drag flag is set to true in the hydrodynamics.yml file.",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#common-customizations",
    "href": "rawFiles/Inputs/inputs.html#common-customizations",
    "title": "Simualtion Inputs",
    "section": "Common Customizations",
    "text": "Common Customizations\nHere are some common customizations you might want to make to the input files:\n\nChanging Vessel Dynamics\nTo adjust a vessel‚Äôs dynamic behavior:\n\nModify hydrodynamic coefficients in hydrodynamics.yml\nAdjust mass and inertia properties in inertia.yml\nChange the center of gravity or buoyancy in geometry.yml\n\n\n\nAdding or Modifying Sensors\nTo add a new sensor:\n\nAdd a new sensor configuration to sensors.yml with appropriate parameters\nSet a realistic update rate and noise characteristics\nPosition the sensor at an appropriate location on the vessel\n\n\n\nCreating a New Vessel\nTo create a new vessel type:\n\nCreate a new folder with the vessel name\nCopy and modify the configuration files from an existing vessel\nAdjust all physical parameters to match the new vessel‚Äôs characteristics\nAdd the new vessel to the agents list in simulation_input.yml",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/Inputs/inputs.html#example-complete-vessel-configuration",
    "href": "rawFiles/Inputs/inputs.html#example-complete-vessel-configuration",
    "title": "Simualtion Inputs",
    "section": "Example: Complete Vessel Configuration",
    "text": "Example: Complete Vessel Configuration\nHere‚Äôs an example of a complete vessel configuration for a surface vessel:\n\nsimulation_input.yml:\n\nsim_time: 100.0\ntime_step: 0.01\ndensity: 1025.0\ngravity: 9.80665\nworld_size: [1000, 1000, 100]\ngps_datum: [13.06, 80.28, 0]\nnagents: 1\n\nagents:\n  - name: \"example_vessel\"\n    type: \"usv\"\n    active_dof: [1, 1, 0, 0, 0, 1]\n    U: 2.0\n    maintain_speed: false\n    geometry: \"inputs/{name}/geometry.yml\"\n    inertia: \"inputs/{name}/inertia.yml\"\n    hydrodynamics: \"inputs/{name}/hydrodynamics.yml\"\n    control_surfaces: \"inputs/{name}/control_surfaces.yml\"\n    thrusters: \"inputs/{name}/thrusters.yml\"\n    initial_conditions: \"inputs/{name}/initial_conditions.yml\"\n    sensors: \"inputs/{name}/sensors.yml\"\n    guidance: \"inputs/{name}/guidance.yml\"\n\ngeometry.yml:\n\ngeometry_file: \"inputs/example_vessel/geometry.gdf\"\nlength: 5.0\nbreadth: 1.5\ndepth: 1.0\n\nCO:\n  position: [0.0, 0.0, 0.0]\n  orientation: [0.0, 0.0, 0.0]\n\nCG:\n  position: [0.0, 0.0, 0.2]\n  orientation: [0.0, 0.0, 0.0]\n\nCB:\n  position: [0.0, 0.0, -0.3]\n  orientation: [0.0, 0.0, 0.0]\n\ngyration: [1.5, 1.5, 0.8]\n\ninertia.yml:\n\nmass: 1000.0\nbuoyancy_mass: 1000.0\ninertia_matrix: \"None\"\nadded_mass_matrix: \"None\"\n\nhydrodynamics.yml:\n\ndim_flag: false\nhydra_file: \"inputs/example_vessel/hydrodynamics.json\"\ncoriolis_flag: true\n\nX_u: -50.0\nX_u_au: -100.0\nY_v: -200.0\nY_v_av: -400.0\nY_r: -50.0\nN_v: -50.0\nN_r: -300.0\nN_r_ar: -400.0\n\ncontrol_surfaces.yml:\n\nnaca_file: \"inputs/naca0015.csv\"\n\ncontrol_surfaces:\n  - control_surface_id: 1\n    control_surface_name: \"Rudder\"\n    control_surface_location: [2.4, 0.0, 0.0]\n    control_surface_orientation: [0, 0, 1.57]\n    control_surface_area: 0.5\n    control_surface_T: 0.5\n    control_surface_delta_max: 35.0\n    control_surface_deltad_max: 20.0\n    control_surface_hydrodynamics: \"None\"\n\nthrusters.yml:\n\nthrusters:\n  - thruster_id: 1\n    thruster_name: \"Main Propeller\"\n    thruster_location: [-2.4, 0.0, 0.0]\n    thruster_orientation: [0.0, 0.0, 0.0]\n    D_prop: 0.4\n    KT_at_J0: 0.5\n    n_max: 1500\n    tp: 0.05\n\ninitial_conditions.yml:\n\nstart_location: [0.0, 0.0, 0.0]\nstart_orientation: [0.0, 0.0, 0.0]\nstart_velocity: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nuse_quaternion: false\n\nsensors.yml:\n\nsensors:\n  - sensor_type: \"IMU\"\n    sensor_topic: \"/vessel/imu\"\n    sensor_location: [0.0, 0.0, 0.1]\n    sensor_orientation: [0.0, 0.0, 0.0]\n    publish_rate: 100\n    use_custom_covariance: true\n    custom_covariance:\n      orientation_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]\n      angular_velocity_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]\n      linear_acceleration_covariance: [0.05, 0.0, 0.0, 0.0, 0.05, 0.0, 0.0, 0.0, 0.05]\n\nguidance.yml:\n\nwaypoints:\n  - [0.0, 0.0, 0.0]\n  - [50.0, 0.0, 0.0]\n  - [50.0, 50.0, 0.0]\n  - [0.0, 50.0, 0.0]\n  - [0.0, 0.0, 0.0]\nwaypoints_type: XYZ",
    "crumbs": [
      "Simualtion Inputs"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html",
    "href": "rawFiles/ROS2/ros2.html",
    "title": "ROS2 Architecture",
    "section": "",
    "text": "Overview\nThe Panisim runs on the Robot Operating System 2 (ROS2), enabling distributed simulation, external control, visualization, and data recording. The ROS2 integration architecture follows a modular design pattern that separates the simulation core from the communication layer. The Docker container of the simlator runs ROS2 Humble.",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#overview",
    "href": "rawFiles/ROS2/ros2.html#overview",
    "title": "ROS2 Architecture",
    "section": "",
    "text": "Tip\n\n\n\nThe ROS2 integration allows the Panisim to run completely isolated from controllers or guidance systems, thus enabling you to code your own controllers or guidance systems to interact with the simulator.",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#architecture",
    "href": "rawFiles/ROS2/ros2.html#architecture",
    "title": "ROS2 Architecture",
    "section": "Architecture",
    "text": "Architecture\nThe ROS2 integration consists of several key components that work together to bridge the simulation with the ROS2 ecosystem:\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nflowchart TB\n    subgraph Simulation[\"Simulation Core\"]\n        World[\"World Class&lt;br&gt;(class_world.py)\"]\n        Vessel[\"Vessel Class&lt;br&gt;(class_vessel.py)\"]\n        Vessel2[\"Vessel Class&lt;br&gt;(Additional Vessels)\"]\n        World --&gt; Vessel\n        World --&gt; Vessel2\n    end\n\n    subgraph ROS2[\"ROS2 Integration\"]\n        World_Node[\"World_Node&lt;br&gt;(class_world_node_ros2.py)\"]\n        Vessel_Pub_Sub[\"Vessel_Pub_Sub&lt;br&gt;(class_vessel_pub_sub_ros2.py)\"]\n        Vessel_Pub_Sub2[\"Vessel_Pub_Sub&lt;br&gt;(Additional Vessels)\"]\n    end\n\n    subgraph Applications[\"ROS2 Ecosystem\"]\n        Controllers[\"External Controllers\"]\n        Visualization[\"Visualization Tools&lt;br&gt;(RViz, Foxglove)\"]\n        Logging[\"Data Logging\"]\n        Other[\"Other ROS2 Nodes\"]\n    end\n\n    Main[\"Main Simulation Script&lt;br&gt;(simulate.py)\"] --&gt; World\n    Main --&gt; World_Node\n    World_Node --&gt; World\n    Vessel --&gt; Vessel_Pub_Sub\n    Vessel2 --&gt; Vessel_Pub_Sub2\n    Vessel_Pub_Sub --&gt; Controllers\n    Vessel_Pub_Sub --&gt; Visualization\n    Vessel_Pub_Sub --&gt; Logging\n    Vessel_Pub_Sub --&gt; Other\n    Vessel_Pub_Sub2 --&gt; Controllers\n    Vessel_Pub_Sub2 --&gt; Visualization\n    Vessel_Pub_Sub2 --&gt; Logging\n    Vessel_Pub_Sub2 --&gt; Other\n    World_Node --- Vessel_Pub_Sub\n    World_Node --- Vessel_Pub_Sub2\n\n    classDef core fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef ros2 fill:#6B8E23,stroke:#2E3B0F,color:white;\n    classDef app fill:#966FD6,stroke:#4A357A,color:white;\n    classDef main fill:#FF6347,stroke:#8B3626,color:white;\n\n    class World,Vessel,Vessel2 core;\n    class World_Node,Vessel_Pub_Sub,Vessel_Pub_Sub2 ros2;\n    class Controllers,Visualization,Logging,Other app;\n    class Main main;\n\n\n\n\n\n\nExplanation of the Architecture Flow:\n\nMain Simulation Script (simulate.py): Initiates the simulation by:\n\nCalling rclpy.init() to initialize the ROS2 middleware\nCreating a World instance by calling World(config_file_path)\nInstantiating a World_Node that wraps the simulation in ROS2\nCalling world.start_vessel_ros_nodes(world_node) to connect vessels to ROS2\n\nWorld Class (class_world.py):\n\nMaintains multiple vessel instances using vessels = []\nProcesses world input with process_world_input(world_file)\nCreates vessels via Vessel(vessel_params, hydrodynamic_data, vessel_id)\nUpdates simulation state with step() method that calls vessel.step() for each vessel\n\nWorld_Node Class (class_world_node_ros2.py):\n\nInherits from ROS2 Node class\nCreates a timer with create_timer(1/self.rate, self.world.step) to drive simulation\n\nVessel_Pub_Sub Class (class_vessel_pub_sub_ros2.py):\n\nCreates publishers, subscribers, and timers for each vessel\nPublishes vessel state and sensor data\nHandles actuator commands via subscribers",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#key-components",
    "href": "rawFiles/ROS2/ros2.html#key-components",
    "title": "ROS2 Architecture",
    "section": "Key Components",
    "text": "Key Components\n\nMain Simulation Script (simulate.py)\nThe entry point for running Panisim with ROS2 integration. This script:\n\nInitializes the ROS2 environment\nCreates the World simulation instance\nSets up the World_Node for ROS2 communication\nEstablishes connections between simulation and ROS2\nRuns the ROS2 spin loop in a separate thread\n\ndef main():\n    # Creates an object of class 'World'\n    rclpy.init()\n    world = World('/workspaces/mavlab/inputs/simulation_input.yml')\n    world_node = World_Node(world_rate=1/world.dt)\n  \n    world.node = world_node\n    world.start_vessel_ros_nodes(world_node)\n\n    # Run ROS on a separate thread\n    ros_thread_instance = threading.Thread(target=ros_thread, args=(world_node,))\n    ros_thread_instance.start()\n    \n    # Prints available ROS2 topics and usage information\n    # ...\nThe ros_thread function is defined as:\ndef ros_thread(node):\n    rclpy.spin(node)\n    rclpy.shutdown()\nThis function handles the ROS2 event loop, allowing callbacks to be processed in the background while the main thread can perform other tasks.\n\n\nWorld Class (class_world.py)\nThe World class serves as the simulation environment container, managing:\n\nMultiple vessel instances within a unified simulation\nInitialization from configuration files\nSimulation time stepping across all vessels\nGlobal parameters like GPS datum and world boundaries\n\nclass World():\n    terminate = False                   # Flag indicating simulation termination\n    vessels = []                        # List of Vessel objects\n    nvessels = 0                        # Number of vessels\n    size = np.zeros(3)                  # Size of the world (X-Y-Z)\n    gps_datum = None                    # GPS reference point\n    node = None                         # ROS2 node reference\n    dt = 0.01                           # Simulation time step\n\n    def __init__(self, world_file=None):\n        \"\"\"Initialize the World object from configuration file\"\"\"\n        if world_file is not None:\n            self.process_world_input(world_file)\n    \n    def step(self):\n        \"\"\"Advance the simulation by one time step\"\"\"\n        for vessel in self.vessels:\n            vessel.step()\nThe process_world_input method reads the simulation configuration from YAML files:\ndef process_world_input(self, world_file=None):\n    try:\n        sim_params, agents = read_input(world_file)\n        self.size = np.array(sim_params['world_size'])\n        self.nvessels = sim_params['nagents']\n        self.gps_datum = np.array(sim_params['gps_datum'])\n        agent_count = 0\n        self.dt = sim_params['time_step']\n        \n        for agent in agents[0:self.nvessels]:\n            vessel_config = agent['vessel_config']\n            hydrodynamic_data = agent['hydrodynamics']\n            self.vessels.append(Vessel(vessel_params=vessel_config, \n                                      hydrodynamic_data=hydrodynamic_data, \n                                      vessel_id=agent_count))\n            agent_count += 1\n    except yaml.YAMLError as exc:\n        print(exc)\n        exit()\nThe World class includes a method to start the ROS2 nodes for all vessels:\ndef start_vessel_ros_nodes(self, world_node):\n    \"\"\"Initialize ROS2 nodes for all vessels in the world\"\"\"\n    for vessel in self.vessels:\n        vessel.vessel_node = Vessel_Pub_Sub(vessel, world_node)\n\n\nWorld_Node Class (class_world_node_ros2.py)\nThe World_Node class is a ROS2 node wrapper for the World class:\nclass World_Node(Node):\n    rate = None\n    def __init__(self, world_rate=100, world_file=None):\n        super().__init__('world')\n        self.rate = world_rate\n        self.world = World(world_file)\n        self.create_timer(1/self.rate, callback=self.world.step)\nThis class: - Inherits from the ROS2 Node class - Creates a timer that triggers the simulation step function at a specified rate - Provides the ROS2 context for the World class\nThe create_timer method sets up a timer that calls the World.step() method at regular intervals determined by world_rate. This is what drives the simulation forward in time while maintaining synchronization with the ROS2 ecosystem.\n\n\nVessel_Pub_Sub Class (class_vessel_pub_sub_ros2.py)\nThe Vessel_Pub_Sub class implements the ROS2 communication interface for vessel objects:\nclass Vessel_Pub_Sub():\n    def __init__(self, vessel, world_node):\n        \"\"\"Initialize the vessel interface\"\"\"\n        self.world_node = world_node\n        self.vessel = vessel\n        self.vessel_id = vessel.vessel_id\n        self.vessel_name = vessel.vessel_name\n        self.topic_prefix = f'{self.vessel_name}_{self.vessel_id:02d}'\n        \n        # Initialize publishers, subscribers, and timers\n        # ...\nThis class:\n\nCreates and manages ROS2 publishers for vessel state and sensor data\nSets up subscribers for actuator commands\nHandles message conversion between simulator data and ROS2 messages\nManages sensor data publication at appropriate rates\n\nKey initialization methods include:\n\nSetting up control surface and thruster mappings\nCreating sensor objects and their publishers\nInitializing odometry and vessel state publishers\nCreating actuator command subscribers",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#message-flow",
    "href": "rawFiles/ROS2/ros2.html#message-flow",
    "title": "ROS2 Architecture",
    "section": "Message Flow",
    "text": "Message Flow\nThe communication between simulation components and the ROS2 ecosystem follows this message flow:\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nsequenceDiagram\n    participant S as Simulation\n    participant VP as Vessel_Pub_Sub\n    participant R as ROS2 Network\n    participant E as External Nodes\n\n    S-&gt;&gt;VP: Vessel state update\n    S-&gt;&gt;VP: Sensor data\n    \n    VP-&gt;&gt;R: Publish odometry\n    VP-&gt;&gt;R: Publish vessel state\n    VP-&gt;&gt;R: Publish sensor data (IMU, GPS, etc.)\n    \n    E-&gt;&gt;R: Subscribe to vessel data\n    E-&gt;&gt;R: Process and visualize\n    \n    E-&gt;&gt;R: Publish control commands\n    R-&gt;&gt;VP: Actuator commands\n    VP-&gt;&gt;S: Update vessel actuators\n    \n    Note over S,VP: Simulation Step\n    S-&gt;&gt;S: Advance simulation\n\n\n\n\n\n\nDetailed Function Call Sequence:\n\nVessel State Update:\n\nvessel.step() in World.step() updates the vessel state\nThis updates vessel.current_state, which is accessed by publishers\n\nSensor Data Generation:\n\nSensor objects call get_measurement() to generate simulated sensor readings based on vessel state\n\nPublishing Data to ROS2:\n\npublish_odometry() is called by a timer to publish vessel position and orientation\npublish_vessel_state() is called by a timer to publish complete state vector\n_publish_sensor() is called by sensor-specific timers to publish sensor data\n\nExternal Nodes Subscribing:\n\nExternal ROS2 nodes subscribe to topics using ros2 topic echo or programmatically\n\nControl Commands:\n\nExternal nodes publish to /&lt;vessel_name&gt;_&lt;id&gt;/actuator_cmd\nactuator_callback(msg) processes these commands\n\nUpdating Actuator States:\n\nvessel.delta_c (control surfaces) and vessel.n_c (thrusters) are updated\nThese affect the vessel dynamics in the next simulation step\n\nSimulation Step:\n\nThe timer in World_Node triggers world.step()\nThis advances all vessels‚Äô states using their dynamics models",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#topics-and-messages",
    "href": "rawFiles/ROS2/ros2.html#topics-and-messages",
    "title": "ROS2 Architecture",
    "section": "Topics and Messages",
    "text": "Topics and Messages\nEach vessel in the simulation publishes data on several ROS2 topics:\n\nStandard Topics\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\n\n\n\n\n/&lt;vessel_name&gt;_&lt;id&gt;/odometry_sim\nnav_msgs/Odometry\nVessel position, orientation, and velocities\n\n\n/&lt;vessel_name&gt;_&lt;id&gt;/vessel_state\nstd_msgs/Float64MultiArray\nComplete vessel state including actuators\n\n\n/&lt;vessel_name&gt;_&lt;id&gt;/actuator_cmd\ninterfaces/Actuator\nCommands for control surfaces and thrusters\n\n\n\n\n\nSensor Topics\nEach sensor configured for a vessel publishes on its own topic:\n\n\n\n\n\n\n\n\nSensor\nTopic\nMessage Type\n\n\n\n\nIMU\n/&lt;vessel_name&gt;_&lt;id&gt;/imu\nsensor_msgs/Imu\n\n\nGPS\n/&lt;vessel_name&gt;_&lt;id&gt;/gps\nsensor_msgs/NavSatFix\n\n\nDVL\n/&lt;vessel_name&gt;_&lt;id&gt;/dvl\ninterfaces/DVL\n\n\nUWB\n/&lt;vessel_name&gt;_&lt;id&gt;/uwb\ngeometry_msgs/PoseWithCovarianceStamped",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#sensor-integration",
    "href": "rawFiles/ROS2/ros2.html#sensor-integration",
    "title": "ROS2 Architecture",
    "section": "Sensor Integration",
    "text": "Sensor Integration\nSensors are created and managed through the Vessel_Pub_Sub class:\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nflowchart LR\n    subgraph VesselConfig[\"Vessel Configuration\"]\n        SensorConfig[\"Sensor Configuration\"]\n    end\n    \n    subgraph VesselPubSub[\"Vessel_Pub_Sub\"]\n        SensorCreation[\"Sensor Creation\"]\n        Publishers[\"Sensor Publishers\"]\n        Timers[\"Publication Timers\"]\n    end\n    \n    subgraph SensorFunctions[\"Sensor Functions\"]\n        GetMeasurement[\"get_measurement()\"]\n        CreateMessage[\"_create_sensor_message()\"]\n        PublishSensor[\"_publish_sensor()\"]\n    end\n    \n    subgraph ROS2[\"ROS2 Network\"]\n        Topics[\"Sensor Topics\"]\n    end\n    \n    SensorConfig --&gt; SensorCreation\n    SensorCreation --&gt; Publishers\n    SensorCreation --&gt; Timers\n    Timers --&gt; PublishSensor\n    PublishSensor --&gt; GetMeasurement\n    PublishSensor --&gt; CreateMessage\n    CreateMessage --&gt; Topics\n    \n    classDef config fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef pubsub fill:#6B8E23,stroke:#2E3B0F,color:white;\n    classDef functions fill:#FFD700,stroke:#B8860B,color:black;\n    classDef network fill:#966FD6,stroke:#4A357A,color:white;\n    \n    class VesselConfig,SensorConfig config;\n    class VesselPubSub,SensorCreation,Publishers,Timers pubsub;\n    class SensorFunctions,GetMeasurement,CreateMessage,PublishSensor functions;\n    class ROS2,Topics network;\n\n\n\n\n\n\nDetailed Function Calls in Sensor Integration:\n\nSensorConfig to SensorCreation:\n\nDuring Vessel_Pub_Sub initialization, it reads sensor configurations from vessel.vessel_config['sensors']\nFor each sensor configuration, it calls create_sensor(sensor_config, vessel_id, topic_prefix, self)\n\nSensorCreation to Publishers and Timers:\n\nAfter creating a sensor object, Vessel_Pub_Sub creates a publisher using:\nself.world_node.create_publisher(self._get_msg_type(sensor.sensor_type), sensor_topic, 10)\nIt also creates a timer for each sensor:\nself.world_node.create_timer(1/sensor.rate, lambda s=sensor: self._publish_sensor(s))\n\nTimer to PublishSensor:\n\nEach timer periodically calls _publish_sensor(sensor) at the sensor‚Äôs configured rate\n\nPublishSensor to GetMeasurement:\n\nThe _publish_sensor method calls sensor.get_measurement() to obtain the latest sensor reading\nEach sensor type has its own implementation of get_measurement()\n\nPublishSensor to CreateMessage:\n\nAfter getting the measurement, _publish_sensor calls _create_sensor_message(sensor_type, measurement)\nThis converts the measurement to the appropriate ROS2 message type\n\nCreateMessage to Topics:\n\nFinally, the message is published to the ROS2 network:\ns['pub'].publish(msg)\n\n\nThe process for sensor integration:\n\nSensor configurations are defined in the vessel parameters (input files sensors.yml)\nThe Vessel_Pub_Sub class creates sensor objects using the create_sensor factory function\nFor each sensor, a publisher and timer are created\nThe timer periodically calls the sensor‚Äôs get_measurement() method\nMeasurements are converted to ROS2 messages and published\n\nKey methods in the sensor integration:\ndef _publish_sensor(self, sensor):\n    \"\"\"Publish sensor data.\"\"\"\n    measurement = sensor.get_measurement()\n    msg = self._create_sensor_message(sensor.sensor_type, measurement)\n    \n    # Find the publisher for this sensor\n    for s in self.sensors:\n        if s['sensor'] == sensor:\n            s['pub'].publish(msg)\n            break\ndef _create_sensor_message(self, sensor_type, measurement):\n    \"\"\"Create a ROS message for sensor data.\"\"\"\n    current_time = self.world_node.get_clock().now().to_msg()\n    \n    # Create appropriate message based on sensor type\n    if sensor_type == 'IMU':\n        msg = Imu()\n        # Fill message fields\n    elif sensor_type == 'GPS':\n        msg = NavSatFix()\n        # Fill message fields\n    # ... other sensor types\n    \n    return msg",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#actuator-control",
    "href": "rawFiles/ROS2/ros2.html#actuator-control",
    "title": "ROS2 Architecture",
    "section": "Actuator Control",
    "text": "Actuator Control\nVessels can be controlled through ROS2 by sending actuator commands:\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nflowchart LR\n    subgraph External[\"External Controller\"]\n        ControlAlgorithm[\"Control Algorithm\"]\n        ActuatorMsg[\"Actuator Message\"]\n    end\n    \n    subgraph ROS2[\"ROS2 Network\"]\n        ActuatorTopic[\"/&lt;vessel_name&gt;_&lt;id&gt;/actuator_cmd\"]\n    end\n    \n    subgraph VesselPubSub[\"Vessel_Pub_Sub\"]\n        Subscriber[\"Actuator Subscriber\"]\n        Callback[\"actuator_callback()\"]\n    end\n    \n    subgraph Vessel[\"Vessel\"]\n        ControlSurfaces[\"Control Surfaces (delta_c)\"]\n        Thrusters[\"Thrusters (n_c)\"]\n    end\n    \n    ControlAlgorithm --&gt; ActuatorMsg\n    ActuatorMsg --&gt; ActuatorTopic\n    ActuatorTopic --&gt; Subscriber\n    Subscriber --&gt; Callback\n    Callback --&gt; ControlSurfaces\n    Callback --&gt; Thrusters\n    \n    classDef external fill:#FF6347,stroke:#8B3626,color:white;\n    classDef ros2 fill:#966FD6,stroke:#4A357A,color:white;\n    classDef pubsub fill:#6B8E23,stroke:#2E3B0F,color:white;\n    classDef vessel fill:#5D8AA8,stroke:#1F456E,color:white;\n    \n    class External,ControlAlgorithm,ActuatorMsg external;\n    class ROS2,ActuatorTopic ros2;\n    class VesselPubSub,Subscriber,Callback pubsub;\n    class Vessel,ControlSurfaces,Thrusters vessel;\n\n\n\n\n\n\nDetailed Function Calls in Actuator Control:\n\nControlAlgorithm to ActuatorMsg:\n\nExternal control algorithms compute desired actuator values\nThey create an Actuator message with the desired values\n\nActuatorMsg to ActuatorTopic:\n\nThe controller publishes the message to the actuator command topic\nThis is done using ROS2‚Äôs publisher.publish(msg) mechanism\n\nActuatorTopic to Subscriber:\n\nThe subscriber in Vessel_Pub_Sub receives the message\nThis was set up during initialization with:\nself.actuator_sub = self.world_node.create_subscription(\n    Actuator, \n    f'{self.topic_prefix}/actuator_cmd', \n    self.actuator_callback, \n    1\n)\n\nSubscriber to Callback:\n\nThe subscriber triggers actuator_callback(msg) in Vessel_Pub_Sub\n\nCallback to ControlSurfaces and Thrusters:\n\nThe callback parses the message and updates vessel control values:\n# For control surfaces\nself.vessel.delta_c[idx] = value * np.pi / 180.0\n\n# For thrusters\nself.vessel.n_c[idx] = value\n\n\n\nActuator Message Structure (Actuator.msg)\nThe Actuator.msg is a custom message type used for controlling vessel actuators. Its structure is:\nstd_msgs/Header header       # Standard header with timestamp\nstring[] actuator_names      # Array of actuator identifiers\nfloat64[] actuator_values    # Array of corresponding values\nThe actuator names use a prefixing convention: - cs_N for control surfaces (e.g., cs_1 for the first control surface) - th_N for thrusters (e.g., th_1 for the first thruster)\nValues for control surfaces are specified in degrees (converted to radians internally) and values for thrusters are in RPM (Revolutions Per Minute).\nExample usage in class_vessel_pub_sub_ros2.py:\ndef actuator_callback(self, msg):\n    \"\"\"Handle actuator command messages.\"\"\"\n    if len(msg.actuator_names) != len(msg.actuator_values):\n        self.world_node.get_logger().warn('Mismatch between actuator IDs and values length')\n        return\n        \n    for actuator_id, value in zip(msg.actuator_names, msg.actuator_values):\n        try:\n            if actuator_id.startswith('cs_'):\n                # Handle control surface (convert degrees to radians)\n                if actuator_id in self.control_surface_ids:\n                    idx = self.control_surface_ids[actuator_id]\n                    self.vessel.delta_c[idx] = value * np.pi / 180.0\n                else:\n                    self.world_node.get_logger().warn(f'Unknown control surface ID: {actuator_id}')\n                    \n            elif actuator_id.startswith('th_'):\n                # Handle thruster (RPM value)\n                if actuator_id in self.thruster_ids:\n                    idx = self.thruster_ids[actuator_id]\n                    self.vessel.n_c[idx] = value\n                else:\n                    self.world_node.get_logger().warn(f'Unknown thruster ID: {actuator_id}')\n                    \n            else:\n                self.world_node.get_logger().warn(f'Invalid actuator ID format: {actuator_id}. Must start with cs_ or th_')\n        except (ValueError, IndexError):\n            self.world_node.get_logger().warn(f'Unknown actuator ID: {actuator_id}')\nDuring initialization, Vessel_Pub_Sub builds mappings between actuator IDs (as defined in control_surfaces.yml and thrusters.yml) and their indices:\n# Store actuator IDs with type prefixes\nself.control_surface_ids = {}  # Maps 'cs_id' to index\nself.thruster_ids = {}        # Maps 'th_id' to index\n    \nfor idx, cs in enumerate(self.control_surfaces):\n    cs_id = cs.get('control_surface_id', idx+1)\n    self.control_surface_ids[f'cs_{cs_id}'] = idx\n\nfor idx, th in enumerate(self.thrusters):\n    th_id = th.get('thruster_id', idx+1)\n    self.thruster_ids[f'th_{th_id}'] = idx\nThese mappings ensure that actuator commands are properly routed to the correct control surfaces and thrusters in the vessel‚Äôs internal state.",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#world-and-vessel-population",
    "href": "rawFiles/ROS2/ros2.html#world-and-vessel-population",
    "title": "ROS2 Architecture",
    "section": "World and Vessel Population",
    "text": "World and Vessel Population\nThe process of populating the world with vessels follows these steps:\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nflowchart TB\n    Start[\"Start Simulation&lt;br&gt;(simulate.py)\"]\n    Init[\"Initialize ROS2\"]\n    CreateWorld[\"Create World&lt;br&gt;(from input file)\"]\n    CreateNode[\"Create World_Node\"]\n    SetNode[\"Set world.node reference\"]\n    StartVessels[\"Start vessel ROS nodes\"]\n    SpinThread[\"Run ROS2 spin in thread\"]\n    PrintInfo[\"Print ROS2 topics and info\"]\n    \n    Start --&gt; Init\n    Init --&gt; CreateWorld\n    CreateWorld --&gt; CreateNode\n    CreateNode --&gt; SetNode\n    SetNode --&gt; StartVessels\n    StartVessels --&gt; SpinThread\n    SpinThread --&gt; PrintInfo\n    \n    CreateWorld -- \"Read from YAML\" --&gt; ReadConfig[\"Read configurations\"]\n    ReadConfig --&gt; ParseWorld[\"Parse world parameters\"]\n    ParseWorld --&gt; CreateVessels[\"Create vessel instances\"]\n    \n    StartVessels --&gt; |\"For each vessel\"| CreateVesselPubSub[\"Create Vessel_Pub_Sub\"]\n    CreateVesselPubSub --&gt; SetupPublishers[\"Set up publishers\"]\n    CreateVesselPubSub --&gt; SetupSubscribers[\"Set up subscribers\"]\n    CreateVesselPubSub --&gt; SetupSensors[\"Set up sensors\"]\n    \n    classDef start fill:#FF6347,stroke:#8B3626,color:white;\n    classDef ros2 fill:#966FD6,stroke:#4A357A,color:white;\n    classDef world fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef vessel fill:#6B8E23,stroke:#2E3B0F,color:white;\n    \n    class Start,Init,SpinThread,PrintInfo start;\n    class CreateNode,SetNode ros2;\n    class CreateWorld,ReadConfig,ParseWorld world;\n    class CreateVessels,StartVessels,CreateVesselPubSub,SetupPublishers,SetupSubscribers,SetupSensors vessel;\n\n\n\n\n\n\nDetailed Function Calls in World and Vessel Population:\n\nStart to Init:\n\nsimulate.py starts and calls rclpy.init() to initialize the ROS2 middleware\nThis initializes the ROS2 context for the application\n\nInit to CreateWorld:\n\nWorld('/workspaces/mavlab/inputs/simulation_input.yml') is called\nThis creates the World instance and loads configuration\n\nCreateWorld to ReadConfig:\n\nWorld.__init__ calls self.process_world_input(world_file)\nprocess_world_input calls read_input(world_file) to parse YAML\n\nReadConfig to ParseWorld:\n\nprocess_world_input extracts world parameters like:\n\nself.size = np.array(sim_params['world_size'])\nself.nvessels = sim_params['nagents']\nself.gps_datum = np.array(sim_params['gps_datum'])\n\n\nParseWorld to CreateVessels:\n\nprocess_world_input creates vessel instances:\nself.vessels.append(Vessel(vessel_params=vessel_config,\n                          hydrodynamic_data=hydrodynamic_data,\n                          vessel_id=agent_count))\n\nCreateWorld to CreateNode:\n\nWorld_Node(world_rate=1/world.dt) is called\nThis creates a ROS2 node wrapper for the World\n\nSetNode to StartVessels:\n\nworld.start_vessel_ros_nodes(world_node) is called\nThis iterates through vessels and creates ROS2 interfaces\n\nStartVessels to CreateVesselPubSub:\n\nVessel_Pub_Sub(vessel, world_node) is called for each vessel\nEach vessel gets its own ROS2 communication interface\n\nCreateVesselPubSub to SetupPublishers:\n\nPublishers are created for each vessel‚Äôs odometry and state:\nself.odometry = {\n    'pub': self.world_node.create_publisher(Odometry, f'{self.topic_prefix}/odometry_sim', 10),\n    'timer': self.world_node.create_timer(self.vessel.vessel_config['time_step'], self.publish_odometry)\n}\n\nCreateVesselPubSub to SetupSubscribers:\n\nSubscribers are created for actuator commands:\nself.actuator_sub = self.world_node.create_subscription(\n    Actuator, \n    f'{self.topic_prefix}/actuator_cmd', \n    self.actuator_callback, \n    1\n)\n\nCreateVesselPubSub to SetupSensors:\n\nSensors are created and configured based on vessel configuration:\nsensor = create_sensor(sensor_config, self.vessel_id, self.topic_prefix, self)\nself.sensors.append({\n    'sensor': sensor,\n    'pub': self.world_node.create_publisher(self._get_msg_type(sensor.sensor_type), sensor_topic, 10),\n    'timer': self.world_node.create_timer(1/sensor.rate, lambda s=sensor: self._publish_sensor(s))\n})\n\nStartVessels to SpinThread:\n\nthreading.Thread(target=ros_thread, args=(world_node,)) is created and started\nThis runs rclpy.spin(node) in a separate thread\n\nSpinThread to PrintInfo:\n\nAvailable ROS2 topics are listed and helpful usage information is printed\n\n\nKey steps in this process:\n\nThe simulation begins in simulate.py\nROS2 is initialized\nA World object is created from the input configuration file\nA World_Node is created and linked to the World object\nVessel ROS nodes are started for each vessel in the world\nFor each vessel, a Vessel_Pub_Sub object is created, which:\n\nSets up publishers for odometry and vessel state\nSets up subscribers for actuator commands\nCreates sensor objects based on the vessel configuration\nSets up timers for publishing sensor data",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#running-the-simulation",
    "href": "rawFiles/ROS2/ros2.html#running-the-simulation",
    "title": "ROS2 Architecture",
    "section": "Running the Simulation",
    "text": "Running the Simulation\nTo run the MAV simulator with ROS2 integration:\n# Navigate to the workspace\ncd /path/to/makara\n\n# Build ROS2 packages\ncolcon build\n\n# Source the workspace\nsource install/setup.bash\n\n# Run the simulator\nros2 run mav_simulator simulate\nAfter starting the simulation, you can interact with it using standard ROS2 commands:\n# List all available topics\nros2 topic list\n\n# Subscribe to vessel odometry\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/odometry_sim\n\n# Publish control commands\nros2 topic pub /&lt;vessel_name&gt;_&lt;id&gt;/actuator_cmd interfaces/Actuator \\\n\"{header: {stamp: {sec: 0}}, actuator_names: ['cs_1', 'th_1'], actuator_values: [15.0, 1200.0]}\"",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/ROS2/ros2.html#best-practices",
    "href": "rawFiles/ROS2/ros2.html#best-practices",
    "title": "ROS2 Architecture",
    "section": "Best Practices",
    "text": "Best Practices\n\nLaunch Files: Create launch files for different simulation scenarios. There are some example launch files in the /workspace/mavlab/ros2_ws/src/mav_simulator/mav_simulator/launch folder.",
    "crumbs": [
      "ROS2 Architecture"
    ]
  },
  {
    "objectID": "rawFiles/WebConfigurator/web_configurator.html",
    "href": "rawFiles/WebConfigurator/web_configurator.html",
    "title": "Vessel Configurator",
    "section": "",
    "text": "Overview\nThe Vessel Configurator is a light weight web-based application that provides an intuitive interface for configuring, and generating input files for the Panisim simulator. This tool eliminates the need to manually create YAML configuration files, offering instead a visual approach to visualize a vessel in 3D and configure its components.\nPreviosly, without the web GUI, one would have to manually enter entries into the YAML files, which was very time consuming and error prone. The major parameters entered in the YAML files are the position and orientation of the various components such as thrusters, control surfaces, sensors etc. With the Web GUI, you simply load a FBX file into the configurator, select your components and the software logs the position and orientation of the components automatically still allowing you to make modifications. You can select the Centre of Buoyancy, Centre of Gravity and Body Centre visually and Panisim takes care of the frame of reference conversion (to the body frame) automatically.",
    "crumbs": [
      "Vessel Configurator"
    ]
  },
  {
    "objectID": "rawFiles/WebConfigurator/web_configurator.html#overview",
    "href": "rawFiles/WebConfigurator/web_configurator.html#overview",
    "title": "Vessel Configurator",
    "section": "",
    "text": "An example configuration in the vessel configurator\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe vessel configurator was largely built using AI!\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe configurator is still needs development and some features may be unstable. The guidance.yml and control.yml files will still need to be manually edited.",
    "crumbs": [
      "Vessel Configurator"
    ]
  },
  {
    "objectID": "rawFiles/WebConfigurator/web_configurator.html#tutorial",
    "href": "rawFiles/WebConfigurator/web_configurator.html#tutorial",
    "title": "Vessel Configurator",
    "section": "Tutorial",
    "text": "Tutorial\nTo Quickstart and playaround, you can load the pre-configured mavymini_config.json vessel model in the /inputs/example configurations folder. Or follow the step below to configure your own vessel.\n\nStep 1: Load a Vessel Model\n\nOpen the vessel configurator in your web browser\nClick on the ‚ÄúChoose Vessel‚Äù button\nSelect the FBX file of the vessel model you want to configure\n\nNow you should see the vessel model in the 3D view.\n\n\n\nLoaded Vessel\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe software automatically calculates the length, breadth and depth of the vessel from the FBX file via a bounding box. if possible, you should have your vessel in the configuration used in marine vessels, i.e X axis along the length of the vessel pointing forward, Y axis along the breadth pointing to the starboard and Z axis along the depth pointing downwards.\n\n\n\n\nStep 2: Configure the Vessel\n\nSelect the component (Control Surfaces, Thrusters, or Sensors) you want to configure. It will be slightly highlighted on selection.\n\n\n\n\nSelected Component\n\n\n\nFrom the left sidebar, switch to the Properties tab and select the component type.\nConfiguration modal would appear on selecting the component type.\n\n\n\n\nComponent Configuration Modal\n\n\n\nEnter the required parameters and click on the ‚ÄúApply‚Äù button.\nThe component will then be configured. This can be confirmed if you see a coordinate system assigned to your vessel.\n\n\n\n\nComponent Configured\n\n\n\nYou should see the position and orientation in the properties tab.\nYou can select the coordinate and transform it in the 3D view based on where you want to place it.\n\n\n\n\nComponent Configured\n\n\nFor sensors, the orientation have to be how you have mounted it on the vessel.\nFor control surfaces, the X axis needs to be along the chord, Y axis pointing along the span inwards to the vessel and Z axis completing the right hand coordinate system.\n\n\n\nControl Surface\n\n\nFor thrusters, the X axis needs to be along the axis of the thruster, Y axis pointing towards the starboard and Z axis completing the right hand coordinate system.\nEverything follows the NED (North, East, Down) coordinate system.\n\n\nStep 3: Placing the vessel center points\n\nMake the vessel transparent to see the inside. And untoggle the ‚ÄúMake 3D Model Selectable‚Äù option. This will allow you to select the centre points and transform them.\n\n\n\n\nTransparent Vessel\n\n\n\nYou can select each of the center points and transform them to the desired location.\nYou can also manually enter the coordinates in the Edit Geometry Parameters in the right sidebar components tab.\nThe Body Centre [CO], is the point with respect to which all other coordinates are defined. And therefore it must be placed in the NED configuration.\n\n\n\nStep 4: Edit Hydrodynamic Coefficients\n\nEdit the hydrodynamic coefficients in the Edit Hydrodynamic Coefficients in the right sidebar components tab. Follow the instructions in the modal to enter the hydrodynamic coefficients.\n\n\n\n\nHydrodynamic Coefficients\n\n\n\n\nStep 5: Simulation settings\n\nEdit all the parameters in the Simulation tab in the right sidebar.\n\n\n\n\n\n\n\nNote\n\n\n\nIn the Advanced Simualtion Parameters, you can visually select the geofence boundaries. This also can be further extended to select waypoints in a future release.\n\n\n\n\n\nGeofence\n\n\n\n\nStep 6: Upload the Hydra output file (optional, if you are not using cross-flow drag)\nYou can get your Hydra output file from the HydRA website. And upload the zip folder in the web gui. The generated input file will then contain your Hydra file with correct path.\n\n\nStep 7: Generate the YAML files\n\nClick on the ‚ÄúGenerate YAML‚Äù button in the toolbar.\nThe YAML files will be generated and downloaded as a zip file.\nUnzip the file and place it in the inputs directory.\n\nAnd there you have it! You have successfully configured your vessel and generated the required input files for the Panisim simulator. Some configuration file may require manual edits. Feel free to play around with the Web GUI and extend its functionality.",
    "crumbs": [
      "Vessel Configurator"
    ]
  },
  {
    "objectID": "rawFiles/WebConfigurator/web_configurator.html#software-architecture",
    "href": "rawFiles/WebConfigurator/web_configurator.html#software-architecture",
    "title": "Vessel Configurator",
    "section": "Software Architecture",
    "text": "Software Architecture\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#5D8AA8', 'primaryTextColor': '#fff', 'primaryBorderColor': '#1F456E', 'lineColor': '#1F456E', 'secondaryColor': '#006400', 'tertiaryColor': '#fff', 'textColor': '#192230' }}}%%\nflowchart TB\n    User[\"User Input\"] --&gt; Interface[\"Web Interface&lt;br&gt;(HTML, CSS, JS)\"]\n    Interface --&gt; ThreeJS[\"3D Visualization&lt;br&gt;(three-setup.js)\"]\n    Interface --&gt; VesselModel[\"Vessel Data Model&lt;br&gt;(vessel-model.js)\"]\n    VesselModel --&gt; YAMLGen[\"YAML Generator&lt;br&gt;(yaml-generator.js)\"]\n    YAMLGen --&gt; SimFiles[\"Simulation Input Files&lt;br&gt;(YAML)\"]\n    \n    classDef user fill:#FF6347,stroke:#8B3626,color:white;\n    classDef interface fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef model fill:#6B8E23,stroke:#2E3B0F,color:white;\n    classDef output fill:#966FD6,stroke:#4A357A,color:white;\n    \n    class User user;\n    class Interface interface;\n    class ThreeJS,VesselModel interface;\n    class YAMLGen model;\n    class SimFiles output;\n\n\n\n\n\n\nThe Vessel Configurator provides a complete workflow for creating and configuring marine vessels with the following key features:\n\nParameter Configuration: Intuitive interfaces for setting physical properties and simulation parameters, GPS waypoints.\nComponent Management: Add, edit, and position thrusters, control surfaces, and sensors\nYAML Generation: Automatic generation of properly formatted configuration files for the simulator\nValidation: Built-in checks to ensure valid component ID configuration\n\n\nCore Components\n\nUser Interface (index.html, styles.css, themes.css)\n\nImplements a responsive, CAD-style interface with Bootstrap 5.3.2 framework integration\nFeatures a component hierarchy with:\n\nPrimary toolbar containing application controls (new/load/save/undo/redo)\nSplit-pane workspace with resizable panels using Split.js\nLeft sidebar with tabbed project explorer and properties inspector\n3D viewport with transform controls and visualization options\nRight sidebar with component addition and configuration panels\nModal dialogs for advanced configuration options and YAML preview\n\nSupports context-sensitive property editing with dynamic form generation\nImplements theme switching functionality with CSS variables for light/dark modes\nMaintains responsive layout through Bootstrap grid system and custom flex containers\n\n3D Visualization Engine (three-setup.js)\n\nImplements a Three.js-based rendering system with WebGL acceleration\nConfigures high-performance renderer with antialiasing, physically correct lighting, and shadow mapping\nManages scene graph with hierarchical component structure and parent-child relationships\nFeatures multiple coordinate systems (world, vessel-local, component-local)\nImplements interactive controls with:\n\nOrbitControls for camera navigation (pan, rotate, zoom)\nTransformControls for direct manipulation (translate, rotate, scale)\nRaycaster-based object selection with visual feedback\n\nProvides real-time synchronization between 3D objects and data model properties\nImplements custom visual feedback systems including:\n\nColor-coded component highlighting for selection state\nLocal axes visualization for component orientation\nText sprite labeling for identification and measurements\nDynamic material updates for selection and hover states\n\nOptimizes rendering performance using:\n\nRequest animation frame with conditional rendering\nEfficient mesh creation with geometry instancing\nAdaptive resolution scaling based on device capabilities\nConditional shadow casting based on object importance\n\n\nVessel Data Model (vessel-model.js)\n\nImplements a comprehensive object-oriented data structure with 1156+ lines of structured code\nMaintains vessel configuration as a deeply nested JavaScript object with strong typing conventions\nOrganizes data in specialized subsystems:\n\nPhysical properties (dimensions, mass, centers)\nHydrodynamic coefficients (added mass, damping, restoring forces)\nComponent collections (control surfaces, thrusters, sensors)\nSimulation parameters (time step, environment, boundary conditions)\n\nProvides transaction-based modification methods with validation:\n\nAddition, update, and removal operations for all component types\nAuto-incrementing ID allocation for component tracking\nReference integrity management between components\nUnit conversion and normalization for consistent data representation\n\nImplements bidirectional mapping between model data and 3D objects using UUID tracking\nMaintains persistence through JSON serialization/deserialization with state version control\nSupports incremental updates through partial property modification methods\n\nYAML Generator (yaml-generator.js)\n\nImplements specialized transformation engine for converting vessel model to simulation-compatible YAML\nFeatures robust numerical formatting with:\n\nConfigurable precision control (4-6 decimal places based on parameter type)\nUnit annotation through comments\nScientific notation for small coefficient values\nArray formatting with dimension-appropriate representation\n\nOrganizes output into standard simulation file hierarchy:\n\ngeometry.yml with vessel dimensions and center points\nhydrodynamics.yml with coefficient grouping by motion direction (X/Y/Z/K/M/N)\ninertia.yml with mass matrix and added mass coefficients\ncontrol_surfaces.yml with NACA profile properties and dynamics\nthrusters.yml with propulsion characteristics and placement\ninitial_conditions.yml with startup position and velocity\nsensors.yml with instrumentation configuration and noise models\n\nGenerates Docker-compatible file paths for simulator integration (/workspaces/mavlab/inputs/...)\nPerforms semantic validation with appropriate warning generation\nUses JSZip library for creating multi-file archives with proper directory structure\n\nUtility Modules\n\ngdf-loader.js: Implements parser for Geometric Data Files (GDF) with:\n\nTriangulated mesh conversion\nHydrodynamic coefficient extraction\nCenter of buoyancy calculation from mesh geometry\n\ncontrols.js: Extends Three.js transform controls with:\n\nCustom snapping behavior for precise positioning\nEvent handling for synchronized model updates\nSpecialized axis constraints for different component types\n\nExternal library integration:\n\nThree.js (r128) for 3D visualization\nJSZip (3.10.1) for configuration packaging\njs-yaml (4.1.0) for YAML parsing/generation\nBootstrap (5.3.2) for UI components\nLeaflet (1.9.4) for geofencing and waypoint mapping\nFileSaver (2.0.5) for client-side file downloads",
    "crumbs": [
      "Vessel Configurator"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html",
    "href": "rawFiles/Example/example.html",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "",
    "text": "Overview\nThis example demonstrates how to create a custom ROS2 package to interact with the Panisim simulator. We‚Äôll build a Guidance, Navigation, and Control (GNC) package that implements a waypoint tracking PID controller for marine vessels. This example covers:",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#overview",
    "href": "rawFiles/Example/example.html#overview",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "",
    "text": "Creating a ROS2 package structure\nImplementing core controller logic\nSetting up ROS2 nodes to interface with the simulator\nBuilding and launching the complete system\n\n\n\n\n\n\n\nTip\n\n\n\nAll the below codes and folders are already implemented in the Repository. This example is only for the reference and to show how you can configure your own ROS2 package to interact with the Panisim simulator.",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#running-the-example",
    "href": "rawFiles/Example/example.html#running-the-example",
    "title": "Example - Waypoint Tracking PID controller",
    "section": "Running the Example",
    "text": "Running the Example\nTo run the waypoint tracking example:\n\nStart the simulator and controllers with:\n\nros2 launch gnc gnc_launch.py\n\nThis launch file starts three main components:\n\nThe Panisim simulator (mav_simulator/simulate)\nThe navigation node (gnc/nav)\nThe guidance control node (gnc/gc) that implements waypoint tracking\n\nOnce running, you can visualize the vessel‚Äôs movement in the web interface at http://localhost:8000\nTo observe the vessel‚Äôs progress, you can monitor various ROS2 topics:\n\n# View waypoints being published\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/waypoints\n\n# View actuator commands being sent to the vessel\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/actuator_cmd\n\n# View the vessel's current position\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/odometry_sim",
    "crumbs": [
      "Example - Waypoint Tracking PID controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#pid-control-principles",
    "href": "rawFiles/Example/example.html#pid-control-principles",
    "title": "Example - Waypoint Tracking PID controller",
    "section": "PID Control Principles",
    "text": "PID Control Principles\nThe waypoint tracking uses a PID (Proportional-Integral-Derivative) controller with a two-loop architecture:\n\nOuter loop: Calculates desired heading based on cross-track error\nInner loop: Calculates rudder command based on heading error\n\nThe controller performs the following steps:\n\nCalculate the cross-track error (perpendicular distance from vessel to path)\nCalculate desired heading using path direction and proportional-integral control on cross-track error\nCalculate rudder command using proportional-derivative control on heading error",
    "crumbs": [
      "Example - Waypoint Tracking PID controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#pid-controller-implementation",
    "href": "rawFiles/Example/example.html#pid-controller-implementation",
    "title": "Example - Waypoint Tracking PID controller",
    "section": "PID Controller Implementation",
    "text": "PID Controller Implementation\nThe controller is implemented in module_control.py. Let‚Äôs examine key aspects of the implementation:\n\n1. Angle Normalization\nThe ssa() (smallest signed angle) function ensures all angle calculations are properly normalized:\ndef ssa(ang, deg=False):\n    \"\"\"\n    Smallest signed angle that lies between -pi and pi.\n    If deg is True, the angle is assumed to be in degrees.\n    If deg is False, the angle is assumed to be in radians.\n    \"\"\"\n    if deg:\n        ang = (ang + 180) % (360.0) - 180.0\n    else:\n        ang = (ang + np.pi) % (2 * np.pi) - np.pi\n    return ang\n\n\n2. Main PID Control Function\nThe pid_control() function calculates the rudder command:\ndef pid_control(t, state, waypoints, waypoint_idx, ye_int=0.0):\n    \"\"\"\n    Implement a PID control strategy to follow the waypoints.\n    \n    Args:\n        t (float): Current simulation time [s]\n        state (ndarray): Current vessel state vector\n        waypoints (ndarray): Waypoints array\n        waypoint_idx (int): Current waypoint index\n        ye_int (float): Integral term of cross-track error\n        \n    Returns:\n        float: Commanded rudder angle in radians\n        float: Cross-track error\n        int: Next waypoint index\n    \"\"\"\n\n\n3. Cross-Track Error Calculation\nThe controller calculates the perpendicular distance from the vessel to the path:\n# Calculate path line equation: ax + by + c = 0\na = -(wp_yn1 - wp_yn)\nb = (wp_xn1 - wp_xn)\nc = -wp_yn1*b-a*wp_xn1\n\n# Calculate cross-track error\nye = -(a*x + b*y + c)/np.sqrt(a**2 + b**2)\n\n\n4. Two-Loop Control Structure\nThe controller uses a two-loop structure for heading and rudder control:\n# Outer loop (heading control)\nKpo = 0.6  # Proportional gain\nKio = 0.05 # Integral gain\npsid = pi_p + Kpo*(-ye) + Kio*(-ye_int)  # Desired heading\n\n# Inner loop (rudder control)\nKpi = 0.7  # Proportional gain\nKdi = 0.5  # Derivative gain\ndelta_c = Kpi*ssa(psid - psi) + Kdi*(rd - r)  # Rudder command\n\n\n5. Waypoint Transition Logic\nThe controller checks if the vessel has reached the current waypoint and updates accordingly:\n# Distance to waypoint\nwp_dist = np.linalg.norm(np.array([x - wp_xn, y - wp_yn, 0.0]))\nif wp_dist &lt; 0.5:  # 0.5m threshold\n    waypoint_idx += 1",
    "crumbs": [
      "Example - Waypoint Tracking PID controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#ros2-integration",
    "href": "rawFiles/Example/example.html#ros2-integration",
    "title": "Example - Waypoint Tracking PID controller",
    "section": "ROS2 Integration",
    "text": "ROS2 Integration\nThe PID controller is integrated with ROS2 through the GuidanceControl class in class_guidance_control.py:\nclass GuidanceControl(Node):\n    def __init__(self, vessel):\n        super().__init__('guidance_controller')\n        \n        # Configure topics based on vessel name and ID\n        self.vessel = vessel\n        self.odom_topic = f'{self.vessel.vessel_name}_{self.vessel.vessel_id:02d}/odometry_sim'\n        self.actuator_topic = f'{self.vessel.vessel_name}_{self.vessel.vessel_id:02d}/actuator_cmd'\n        self.waypoints_topic = f'{self.vessel.vessel_name}_{self.vessel.vessel_id:02d}/waypoints'\n        \n        # Create subscriber for odometry\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            self.odom_topic,\n            self.odom_callback,\n            10)\n            \n        # Create publisher for rudder command\n        self.actuator_pub = self.create_publisher(\n            Actuator,\n            self.actuator_topic,\n            10)\n        \n        # Create publisher for waypoints\n        self.waypoints_pub = self.create_publisher(\n            PoseArray,\n            self.waypoints_topic,\n            10)\n\nOdometry Callback\nThe odom_callback method processes vessel state updates and calculates control commands:\ndef odom_callback(self, msg):\n    # Extract vessel state from odometry message\n    # ...\n    \n    # Calculate control command using PID controller\n    rudder_cmd, ye, wp_indx = self.control_mode(t, state, self.waypoints, self.waypoint_idx, self.ye_int)\n    \n    # Handle waypoint transitions\n    if wp_indx != self.waypoint_idx:\n        self.get_logger().info(f'Waypoint {self.waypoint_idx} reached')\n        self.waypoint_idx = wp_indx\n        self.ye_int = 0.0  # Reset integral term\n        \n        # Loop back to first waypoint when all are visited\n        if self.waypoint_idx &gt;= len(self.waypoints):\n            self.get_logger().info('***All waypoints reached***')\n            self.waypoint_idx = 1\n    \n    # Update integral term\n    dt = t - self.te_int\n    if dt &gt; 0:\n        self.ye_int += ye * dt\n        self.te_int = t\n    \n    # Publish actuator command\n    cmd_msg = Actuator()\n    cmd_msg.actuator_values = [float(rudder_cmd * 180 / np.pi)]  # Convert to degrees\n    cmd_msg.actuator_names = ['cs_1']  # Control surface 1\n    cmd_msg.covariance = [0.0]\n    self.actuator_pub.publish(cmd_msg)\n\n\nWaypoint Publishing\nThe publish_waypoints method publishes waypoints for visualization:\ndef publish_waypoints(self):\n    if not self.waypoints_data:\n        return\n        \n    pose_array = PoseArray()\n    pose_array.header.stamp = self.get_clock().now().to_msg()\n    pose_array.header.frame_id = \"map\"\n    \n    for waypoint in self.waypoints_data.get('waypoints', []):\n        pose = Pose()\n        pose.position.x = float(waypoint[0])\n        pose.position.y = float(waypoint[1])\n        pose.position.z = float(waypoint[2])\n        pose_array.poses.append(pose)\n    \n    self.waypoints_pub.publish(pose_array)",
    "crumbs": [
      "Example - Waypoint Tracking PID controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#configuring-waypoints",
    "href": "rawFiles/Example/example.html#configuring-waypoints",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Configuring Waypoints",
    "text": "Configuring Waypoints\nWaypoints for vessel navigation are defined in the guidance.yaml input file:\nwaypoints_type: XYZ\nwaypoints:\n- [0.0, 0.0, 0.0]     # Starting point\n- [10.0, 0.0, 0.0]    # First waypoint\n- [50.0, 50.0, 0.0]   # Second waypoint\n- [0.0, 50.0, 0.0]    # Third waypoint\n- [0.0, 0.0, 0.0]     # Return to start",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#tuning-the-controller",
    "href": "rawFiles/Example/example.html#tuning-the-controller",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Tuning the Controller",
    "text": "Tuning the Controller\nTo optimize the controller performance, you can adjust the PID gains in module_control.py:\n\nOuter loop gains control how the vessel corrects its path:\n\nKpo: Proportional gain for cross-track error (higher = more aggressive correction)\nKio: Integral gain for cross-track error (higher = better steady-state error reduction)\n\nInner loop gains control how the rudder responds:\n\nKpi: Proportional gain for heading error (higher = stronger rudder response)\nKdi: Derivative gain for heading rate (higher = more damping)\n\nWaypoint acceptance radius (0.5m by default) determines how close the vessel must get to a waypoint before moving to the next one.",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#visualization-and-analysis",
    "href": "rawFiles/Example/example.html#visualization-and-analysis",
    "title": "Example - Waypoint Tracking PID controller",
    "section": "Visualization and Analysis",
    "text": "Visualization and Analysis\nWhen running the example, you‚Äôll see:\n\nThe vessel moves toward the first waypoint, adjusting its heading to follow the path\nThe web interface shows the vessel‚Äôs position and orientation in real-time\nTerminal messages indicate when waypoints are reached\n\nImportant metrics to observe:\n\nCross-track error: How far the vessel deviates from the desired path\nRudder activity: Excessive rudder movement indicates potential controller instability\nWaypoint transition: How smoothly the vessel transitions between path segments",
    "crumbs": [
      "Example - Waypoint Tracking PID controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#conclusion",
    "href": "rawFiles/Example/example.html#conclusion",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Conclusion",
    "text": "Conclusion\nThis example demonstrated how to create a custom ROS2 package that interacts with the Panisim simulator to provide waypoint tracking capabilities for marine vessels. The modular structure allows for easy extension and modification to meet diverse control requirements.\nBy following similar patterns, you can develop your own ROS2 packages to implement various GNC algorithms and integrate them with the Panisim simulator.",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#creating-the-ros2-package",
    "href": "rawFiles/Example/example.html#creating-the-ros2-package",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Creating the ROS2 Package",
    "text": "Creating the ROS2 Package\n\n1. Package Structure\nFirst, let‚Äôs create a new ROS2 package called gnc in the ros2_ws/src directory:\ncd ros2_ws/src\nros2 pkg create --build-type ament_python gnc --dependencies rclpy nav_msgs geometry_msgs interfaces\nThis creates a basic package structure:\ngnc/\n‚îú‚îÄ‚îÄ gnc/\n‚îÇ   ‚îî‚îÄ‚îÄ __init__.py\n‚îú‚îÄ‚îÄ package.xml\n‚îú‚îÄ‚îÄ setup.py\n‚îî‚îÄ‚îÄ setup.cfg\n\n\n2. Update Package Dependencies\nEdit package.xml to include all required dependencies:\n&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;gnc&lt;/name&gt;\n  &lt;version&gt;0.0.1&lt;/version&gt;\n  &lt;description&gt;Guidance, Navigation and Control package for Panisim&lt;/description&gt;\n  &lt;maintainer email=\"example@example.com\"&gt;user&lt;/maintainer&gt;\n  &lt;license&gt;Apache License 2.0&lt;/license&gt;\n\n  &lt;depend&gt;rclpy&lt;/depend&gt;\n  &lt;depend&gt;nav_msgs&lt;/depend&gt;\n  &lt;depend&gt;geometry_msgs&lt;/depend&gt;\n  &lt;depend&gt;std_msgs&lt;/depend&gt;\n  &lt;depend&gt;interfaces&lt;/depend&gt;\n  &lt;depend&gt;mav_simulator&lt;/depend&gt;\n  \n  &lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;\n\n  &lt;export&gt;\n    &lt;build_type&gt;ament_python&lt;/build_type&gt;\n  &lt;/export&gt;\n&lt;/package&gt;\n\n\n3. Configure Setup Scripts\nUpdate setup.py to include our entry points and specify dependencies:\nfrom setuptools import setup\nimport os\nfrom glob import glob\n\npackage_name = 'gnc'\n\nsetup(\n    name=package_name,\n    version='0.0.1',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),\n        (os.path.join('share', package_name, 'web'), glob('web/**/*', recursive=True)),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='user',\n    maintainer_email='example@example.com',\n    description='Guidance, Navigation and Control package for Panisim',\n    license='Apache License 2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'gc = gnc.guidance_control:main',\n            'nav = gnc.navigation:main',\n        ],\n    },\n)\n\n\n4. Create Directory Structure\nSet up the complete directory structure:\nmkdir -p gnc/launch\nmkdir -p gnc/web",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#implementing-the-controller-logic",
    "href": "rawFiles/Example/example.html#implementing-the-controller-logic",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Implementing the Controller Logic",
    "text": "Implementing the Controller Logic\n\n1. Control Module\nFirst, create module_control.py in the gnc package to implement the PID control logic:\n# ros2_ws/src/gnc/gnc/module_control.py\nimport numpy as np\n\n\"\"\"\nRudder control module for vessel simulation.\n\nThis module provides rudder control strategies for vessel steering with PID controllers.\n\"\"\"\n\ndef ssa(ang, deg=False):\n    \"\"\"\n    Smallest signed angle that lies between -pi and pi.\n    If deg is True, the angle is assumed to be in degrees and is converted to radians.\n    If deg is False, the angle is assumed to be in radians.\n    \"\"\"\n    if deg:\n        ang = (ang + 180) % (360.0) - 180.0\n    else:\n        ang = (ang + np.pi) % (2 * np.pi) - np.pi\n    return ang\n\ndef clip(val, min_val, max_val):\n    \"\"\"\n    Clip a value to a range.\n    \"\"\"\n    return max(min_val, min(val, max_val))\n\ndef pid_control(t, state, waypoints, waypoint_idx, ye_int=0.0):\n    \"\"\"\n    Implement a PID control strategy to follow the waypoints. \n    \n    Args:\n        t (float): Current simulation time [s]\n        state (ndarray): Current vessel state vector\n        waypoints (ndarray): Waypoints array\n        waypoint_idx (int): Current waypoint index\n        ye_int (float): Integral term of cross-track error\n        \n    Returns:\n        float: Commanded rudder angle in radians\n        float: Cross-track error\n        int: Next waypoint index\n    \"\"\"\n\n    # Check if we have reached the last waypoint\n    if waypoint_idx == len(waypoints):\n        return 0.0, 0.0, waypoint_idx\n\n    # Current state\n    u, v, r = state[3], state[4], state[5]\n    x, y, psi = state[6], state[7], state[11]\n    \n    # Current and previous waypoints\n    wp_xn, wp_yn, _ = waypoints[waypoint_idx]\n    wp_xn1, wp_yn1, _ = waypoints[waypoint_idx - 1]\n\n    # Calculate path line equation: ax + by + c = 0\n    a = -(wp_yn1 - wp_yn)\n    b = (wp_xn1 - wp_xn)\n    c = -wp_yn1*b-a*wp_xn1\n    \n    # Path direction unit vector\n    wp_unit_vec = np.array([wp_xn - wp_xn1, wp_yn - wp_yn1, 0.0])\n    wp_unit_vec = wp_unit_vec / np.linalg.norm(wp_unit_vec)\n\n    # Calculate cross-track error\n    ye = -(a*x + b*y + c)/np.sqrt(a**2 + b**2)\n    \n    # Path direction angle\n    pi_p = np.angle(wp_unit_vec[0] + 1j * wp_unit_vec[1]) \n\n    # Outer loop PID gains\n    Kpo = 0.6  # Proportional gain\n    Kio = 0.05 # Integral gain\n    \n    # Desired heading (outer loop control)\n    psid = pi_p + Kpo*(-ye) + Kio*(-ye_int)\n   \n    # Inner loop PID gains\n    Kpi = 0.7  # Proportional gain\n    Kdi = 0.5  # Derivative gain\n    \n    # Rudder command (inner loop control)\n    delta_c = Kpi*ssa(psid - psi) + Kdi*(0 - r)\n    \n    # Clip the rudder angle\n    delta_c = clip(delta_c, -35*np.pi/180, 35*np.pi/180)\n\n    # Distance to waypoint\n    wp_dist = np.linalg.norm(np.array([x - wp_xn, y - wp_yn, 0.0]))\n    if wp_dist &lt; 0.5:  # 0.5m threshold\n        waypoint_idx += 1\n\n    # Return negative delta_c (due to sign convention of rudder angle)\n    return -delta_c, ye, waypoint_idx\n\n\n2. Guidance Control Node Class\nNext, create class_guidance_control.py to implement the ROS2 node class:\n# ros2_ws/src/gnc/gnc/class_guidance_control.py\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Odometry\nfrom interfaces.msg import Actuator\nfrom geometry_msgs.msg import PoseArray, Pose\nfrom mav_simulator.module_kinematics import quat_to_eul\nimport gnc.module_control as con\nimport numpy as np\n\nclass GuidanceControl(Node):\n    def __init__(self, vessel):\n        super().__init__('guidance_controller')\n\n        self.vessel = vessel\n        \n        # Configure topics based on vessel name and ID\n        self.odom_topic = f'{self.vessel.vessel_name}_{self.vessel.vessel_id:02d}/odometry_sim'\n        self.actuator_topic = f'{self.vessel.vessel_name}_{self.vessel.vessel_id:02d}/actuator_cmd'\n        self.waypoints_topic = f'{self.vessel.vessel_name}_{self.vessel.vessel_id:02d}/waypoints'\n        \n        # Create subscriber for odometry\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            self.odom_topic,\n            self.odom_callback,\n            10)\n            \n        # Create publisher for rudder command\n        self.actuator_pub = self.create_publisher(\n            Actuator,\n            self.actuator_topic,\n            10)\n        \n        # Create publisher for waypoints\n        self.waypoints_pub = self.create_publisher(\n            PoseArray,\n            self.waypoints_topic,\n            10)\n        \n        # Set up timer to publish waypoints\n        self.timer = self.create_timer(1.0, self.publish_waypoints)\n        \n        # Read waypoints from vessel configuration\n        self.waypoints = np.array(self.vessel.vessel_config['guidance']['waypoints'])\n        self.waypoints_type = self.vessel.vessel_config['guidance']['waypoints_type']\n        self.waypoint_idx = 1\n\n        self.waypoints_data = {\n            'waypoints': self.waypoints,\n            'waypoints_type': self.waypoints_type\n        }\n        \n        # Initialize time\n        self.start_time = self.get_clock().now()\n\n        # Initialize integrator\n        self.ye_int = 0.0\n        self.te_int = 0.0\n        \n        # Select control mode\n        self.control_mode = con.pid_control\n        \n        self.get_logger().info('Guidance Controller initialized')\n\n    def publish_waypoints(self):\n        \"\"\"Publish waypoints for visualization\"\"\"\n        if not self.waypoints_data:\n            return\n            \n        pose_array = PoseArray()\n        pose_array.header.stamp = self.get_clock().now().to_msg()\n        pose_array.header.frame_id = \"map\"\n        \n        for waypoint in self.waypoints_data.get('waypoints', []):\n            pose = Pose()\n            pose.position.x = float(waypoint[0])\n            pose.position.y = float(waypoint[1])\n            pose.position.z = float(waypoint[2])\n            pose_array.poses.append(pose)\n        \n        self.waypoints_pub.publish(pose_array)\n    \n    def odom_callback(self, msg):\n        \"\"\"Process odometry data and calculate control commands\"\"\"\n        # Get current time in seconds\n        current_time = self.get_clock().now()\n        t = (current_time - self.start_time).nanoseconds / 1e9\n\n        # Extract orientation quaternion\n        quat = np.array([\n            msg.pose.pose.orientation.w,\n            msg.pose.pose.orientation.x,\n            msg.pose.pose.orientation.y,\n            msg.pose.pose.orientation.z\n        ])\n\n        # Convert quaternion to Euler angles\n        eul = quat_to_eul(quat, order='ZYX')\n        \n        # Create state vector from odometry\n        state = np.array([            \n            msg.twist.twist.linear.x,\n            msg.twist.twist.linear.y,\n            msg.twist.twist.linear.z,\n            msg.twist.twist.angular.x,\n            msg.twist.twist.angular.y,\n            msg.twist.twist.angular.z,\n            msg.pose.pose.position.x,\n            msg.pose.pose.position.y,\n            msg.pose.pose.position.z,\n            eul[0],\n            eul[1],\n            eul[2],\n            0.0 # rudder angle\n        ])\n\n        # Calculate control command\n        rudder_cmd, ye, wp_indx = self.control_mode(t, state, self.waypoints, self.waypoint_idx, self.ye_int)\n\n        # Handle waypoint transitions\n        if wp_indx != self.waypoint_idx:\n            self.get_logger().info(f'Waypoint {self.waypoint_idx} reached')\n            self.waypoint_idx = wp_indx\n            self.ye_int = 0.0  # Reset integral term\n\n            # Loop back to first waypoint when all are visited\n            if self.waypoint_idx &gt;= len(self.waypoints):\n                self.get_logger().info('***All waypoints reached***')\n                self.waypoint_idx = 1\n\n        # Calculate time difference for integration\n        dt = t - self.te_int\n        if dt &gt; 0:  # Avoid division by zero or negative time\n            # Update the integral term\n            self.ye_int += ye * dt\n            self.te_int = t\n        \n        # Publish actuator command\n        cmd_msg = Actuator()\n        cmd_msg.actuator_values = [float(rudder_cmd * 180 / np.pi)]  # Convert to degrees\n        cmd_msg.actuator_names = ['cs_1']  # Control surface 1\n        cmd_msg.covariance = [0.0]\n        self.actuator_pub.publish(cmd_msg)\n\n\n3. Main Entry Point\nCreate guidance_control.py to serve as the entry point for the ROS2 node:\n# ros2_ws/src/gnc/gnc/guidance_control.py\nimport rclpy\nfrom gnc.class_guidance_control import GuidanceControl\nfrom mav_simulator.class_world import World\nfrom rclpy.executors import MultiThreadedExecutor\n\ndef main():\n    # Initialize ROS2\n    rclpy.init()\n    \n    # Load world and vessels from configuration\n    world = World('/workspaces/mavlab/inputs/simulation_input.yml')\n    vessels = world.vessels\n    \n    # Create multi-threaded executor\n    executor = MultiThreadedExecutor()\n    \n    # Initialize guidance controllers for all vessels\n    gcs = []\n    for vessel in vessels:\n        gcs.append(GuidanceControl(vessel))\n        executor.add_node(gcs[-1])\n    \n    try: \n        # Start spinning the nodes\n        executor.spin()\n\n    finally:\n        # Clean up on shutdown\n        executor.shutdown()\n        \n        for gc in gcs:\n            gc.destroy_node()\n        \n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\n\n4. Create a Navigation Node Placeholder\nAdd a simple placeholder for the navigation node to satisfy the launch file requirements:\n# ros2_ws/src/gnc/gnc/navigation.py\nimport rclpy\nfrom rclpy.node import Node\n\nclass Navigation(Node):\n    def __init__(self):\n        super().__init__('navigation')\n        self.get_logger().info('Navigation node started')\n\ndef main():\n    rclpy.init()\n    node = Navigation()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#creating-the-launch-file",
    "href": "rawFiles/Example/example.html#creating-the-launch-file",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Creating the Launch File",
    "text": "Creating the Launch File\nCreate a launch file to start all components of the system:\n# ros2_ws/src/gnc/launch/gnc_launch.py\nimport os\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch import LaunchDescription\nfrom launch.actions import ExecuteProcess, IncludeLaunchDescription\nfrom launch.launch_description_sources import AnyLaunchDescriptionSource\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom mav_simulator.class_world import World\nfrom launch.substitutions import LaunchConfiguration\nfrom launch.actions import GroupAction\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import PushRosNamespace\n\ndef generate_launch_description():\n\n    rosbridge_launch = PathJoinSubstitution([\n        FindPackageShare('rosbridge_server'),\n        'launch',\n        'rosbridge_websocket_launch.xml'\n    ])\n\n    # Path to the web directory in gnc package\n    web_dir = PathJoinSubstitution([\n        FindPackageShare('gnc'),\n        'web'\n    ])\n\n    web_build_dir = '/workspaces/mavlab/ros2_ws/src/mav_simulator/web'\n\n    return LaunchDescription([\n        Node(\n            package='mav_simulator',  # Replace with your package name\n            executable='simulate',  # Replace with your script name\n            name='mavsim',\n            output='screen'\n        ),\n        Node(\n            package='gnc',\n            executable='nav',\n            name='nav',\n            output='screen'\n        ),\n        Node(\n            package='gnc',\n            executable='gc',\n            name='gc',\n            output='screen'\n        ),        \n        # Start the HTTP server to serve the web interface\n        ExecuteProcess(\n            cmd=['python3', '-m', 'http.server', '8000', '--directory', web_build_dir],\n            name='http_server',\n            output='screen'\n        ),\n        # Start the rosbridge server\n        IncludeLaunchDescription(\n            AnyLaunchDescriptionSource(rosbridge_launch)\n        )\n    ])",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#building-and-launching-the-package",
    "href": "rawFiles/Example/example.html#building-and-launching-the-package",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Building and Launching the Package",
    "text": "Building and Launching the Package\nWith all the files in place, you can build and launch your custom ROS2 package:\n\n1. Build the Package\ncd /workspaces/mavlab/ros2_ws\ncolcon build --packages-select gnc\nsource install/setup.bash\n\n\n2. Launch the System\nros2 launch gnc gnc_launch.py\nThis will start: 1. The Panisim simulator 2. The navigation node 3. The guidance control node with waypoint tracking",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#monitoring-system-performance",
    "href": "rawFiles/Example/example.html#monitoring-system-performance",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Monitoring System Performance",
    "text": "Monitoring System Performance\nOnce the system is running, you can monitor various aspects of the waypoint tracking:\n# View odometry data\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/odometry_sim\n\n# View actuator commands\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/actuator_cmd\n\n# View waypoints\nros2 topic echo /&lt;vessel_name&gt;_&lt;id&gt;/waypoints\nYou can also visualize the vessel‚Äôs movement in the web interface at http://localhost:8000.",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#extending-the-controller",
    "href": "rawFiles/Example/example.html#extending-the-controller",
    "title": "Example - Creating a ROS2 Waypoint Tracking Controller",
    "section": "Extending the Controller",
    "text": "Extending the Controller\nThis example provides a foundation for more complex vessel control systems. You can extend it in several ways:\n\nAdd more control strategies in module_control.py\nImplement state estimation in the navigation node\nAdd obstacle avoidance capabilities\nImplement path planning algorithms\nCreate more sophisticated controllers (MPC, adaptive control, etc.)",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking Controller"
    ]
  },
  {
    "objectID": "rawFiles/Example/example.html#web-visualization-interface",
    "href": "rawFiles/Example/example.html#web-visualization-interface",
    "title": "Example - Creating a ROS2 Waypoint Tracking PID Controller",
    "section": "Web Visualization Interface",
    "text": "Web Visualization Interface\nThe GNC package includes a web-based visualization interface that allows you to monitor the vessel‚Äôs state and performance in real-time. This interface uses the rosbridge WebSocket server to communicate with ROS2 and displays vessel odometry and actuator data.\n\nWeb Interface Architecture\n\n\n\n\n\nflowchart TB\n    subgraph \"ROS2 Network\"\n        Topics[\"ROS2 Topics\"]\n        Bridge[\"rosbridge_server\"]\n    end\n    \n    subgraph \"Web Interface\"\n        Server[\"HTTP Server\"]\n        HTML[\"index.html\"]\n        JS[\"main.js\"]\n        Charts[\"Chart.js Visualizations\"]\n    end\n    \n    Topics -- \"Odometry, Actuator Data\" --&gt; Bridge\n    Bridge -- \"WebSocket Protocol\" --&gt; JS\n    JS -- \"Data Processing\" --&gt; Charts\n    HTML -- \"Layout Structure\" --&gt; Charts\n    Server -- \"Serves Files\" --&gt; HTML\n    Server -- \"Serves Files\" --&gt; JS\n    \n    classDef ros fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef web fill:#6B8E23,stroke:#2E3B0F,color:white;\n    \n    class Topics,Bridge ros;\n    class Server,HTML,JS,Charts web;\n\n\n\n\n\n\n\n\nSetting Up the Web Interfac\nThe web interface is automatically set up as part of the launch file. However, if you want to create it from scratch, follow these steps:\n\nCreate a web directory in your package:\n\nmkdir -p ros2_ws/src/gnc/web\n\nCreate the basic HTML structure in index.html:\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\" /&gt;\n  &lt;title&gt;Live Odometry Visualization&lt;/title&gt;\n  &lt;!-- Include Chart.js --&gt;\n  &lt;script src=\"https://cdn.jsdelivr.net/npm/chart.js\"&gt;&lt;/script&gt;\n  &lt;!-- Include ROSLIBJS --&gt;  \n  &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/roslibjs/1.1.0/roslib.min.js\"&gt;&lt;/script&gt;\n  &lt;style&gt;\n    /* Add your CSS styles here */\n    body {\n      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n      max-width: 1200px;\n      margin: 0 auto;\n      padding: 20px;\n      background-color: #f5f5f5;\n    }\n    \n    .chart-container {\n      background: white;\n      border-radius: 10px;\n      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n      padding: 20px;\n      margin: 20px auto;\n    }\n\n    /* More styles... */\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Odometry Data Visualization&lt;/h1&gt;\n\n  &lt;div class=\"chart-container\"&gt;\n    &lt;h2&gt;Path&lt;/h2&gt;\n    &lt;canvas id=\"pathChart\"&gt;&lt;/canvas&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Add more chart containers for position, velocity, etc. --&gt;\n  \n  &lt;div class=\"chart-container\"&gt;\n    &lt;h2&gt;Actuators&lt;/h2&gt;\n    &lt;div id=\"actuatorCharts\"&gt;\n      &lt;!-- Actuator charts will be dynamically added here --&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Main JavaScript file --&gt;\n  &lt;script src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nCreate the JavaScript file main.js to handle ROS2 communication and data visualization:\n\n// Connect to rosbridge websocket\nvar ros = new ROSLIB.Ros({\n  url: 'ws://localhost:9090'\n});\n\nros.on('connection', function() {\n  console.log('Connected to rosbridge.');\n  // Get all topics once connected\n  getTopics();\n});\n\n// Store subscribers\nvar odomSubscribers = {};\nvar actuatorSubscribers = {};\n\n// Get topics and subscribe to relevant ones\nfunction getTopics() {\n  ros.getTopics(function(topics) {\n    var odomTopics = topics.topics.filter(topic =&gt; \n      topic.endsWith('/odometry') || topic.endsWith('/odometry_sim'));\n    var actuatorTopics = topics.topics.filter(topic =&gt; \n      topic.endsWith('/actuator_cmd'));\n    \n    // Subscribe to odometry topics\n    odomTopics.forEach(topic =&gt; {\n      // Subscribe and set up data processing\n    });\n    \n    // Subscribe to actuator topics\n    actuatorTopics.forEach(topic =&gt; {\n      // Subscribe and set up data processing\n    });\n  });\n}\n\n// Set up Chart.js visualizations\nvar pathChart = new Chart(document.getElementById('pathChart').getContext('2d'), {\n  // Chart configuration\n});\n\n// Helper functions for data processing and chart updates\nfunction processOdomMessage(topicName, message) {\n  // Extract and process odometry data\n  // Update charts\n}\n\nfunction processActuatorMessage(topicName, message) {\n  // Extract and process actuator data\n  // Update charts\n}\n\n// More functionality...\n\n\nRunning the Web Interface\nThe web interface is automatically started by the launch file with the following components:\n\nAn HTTP server to serve the web files:\n\nExecuteProcess(\n    cmd=['python3', '-m', 'http.server', '8000', '--directory', web_build_dir],\n    name='http_server',\n    output='screen'\n)\n\nThe rosbridge WebSocket server for ROS2 communication:\n\nIncludeLaunchDescription(\n    AnyLaunchDescriptionSource(rosbridge_launch)\n)\n\n\nWeb Interface Features\nThe web visualization interface includes the following features:\n\nPath Visualization: Displays the vessel‚Äôs path on a 2D plot\nPosition Graphs: Shows X, Y, and Z positions over time\nVelocity Graphs: Displays surge (u), sway (v), and heave (w) velocities\nOrientation Graphs: Shows roll, pitch, and yaw angles\nAngular Velocity Graphs: Displays p, q, and r angular rates\nActuator Visualization: Shows rudder angles and other control inputs\n3D visualization: Shows the vessel‚Äôs position in 3D space\n\n\n\nCustomizing the Web Interface\nYou can customize the web interface by modifying the HTML, CSS, and JavaScript files:\n\nAdd new visualization charts by adding canvas elements in index.html\nChange the layout and styling in the CSS section\nAdd new data processing functions in main.js\nSubscribe to additional ROS2 topics for more comprehensive monitoring\n\n\n\nAccessing the Web Interface\nOnce the system is running, you can access the web interface by opening a web browser and navigating to:\nhttp://localhost:8000\nThe interface automatically connects to the rosbridge server and starts displaying data from available topics.",
    "crumbs": [
      "Example - Creating a ROS2 Waypoint Tracking PID Controller"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html",
    "href": "rawFiles/WebVisualization/web_visualization.html",
    "title": "Simulation Visualization Dashboard",
    "section": "",
    "text": "Overview\nPanisim provides a web-based visualization dashboard to monitor vessel simulation in real-time. The dashboard offers a comprehensive interface for monitoring vessel state, visualizing trajectories, viewing sensor data, and interacting with the simulation.\nThe visualization system consists of two main components:\nflowchart LR\n    subgraph ROS2[\"ROS2 Environment\"]\n        Sim[\"Panisim Simulator\"]\n        Bridge[\"ROS Bridge Server\"]\n    end\n    \n    subgraph Web[\"Web Interface\"]\n        Dashboard[\"2D Dashboard&lt;br&gt;(index.html)\"]\n        View3D[\"3D Visualization&lt;br&gt;(vessel3d.html)\"]\n        JSLib[\"Web Client&lt;br&gt;(main.js)\"]\n    end\n    \n    Sim --&gt;|\"Vessel State&lt;br&gt;Odometry&lt;br&gt;Sensor Data\"| Bridge\n    Bridge --&gt;|\"WebSocket&lt;br&gt;Communication\"| JSLib\n    JSLib --&gt; Dashboard\n    JSLib --&gt; View3D\n\n    classDef ros fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef web fill:#6B8E23,stroke:#2E3B0F,color:white;\n    \n    class Sim,Bridge ros;\n    class Dashboard,View3D,JSLib web;",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#overview",
    "href": "rawFiles/WebVisualization/web_visualization.html#overview",
    "title": "Simulation Visualization Dashboard",
    "section": "",
    "text": "2D Dashboard - A data-rich interface showing vessel state, charts, and control inputs\n3D Visualization - A three-dimensional view of the vessel in its environment with position and orientation\n\n\n\n\nWay-point trackingSimulation Visualization",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#starting-the-visualization",
    "href": "rawFiles/WebVisualization/web_visualization.html#starting-the-visualization",
    "title": "Simulation Visualization Dashboard",
    "section": "Starting the Visualization",
    "text": "Starting the Visualization\nThe web interface is automatically started when launching the Panisim simulator. It uses:\n\nA lightweight HTTP server to host the web files\nThe ROS Bridge server for WebSocket communication with ROS2\n\nThe visualization launches when running the simulation:\nros2 launch gnc gnc_launch.py\nOnce started, you can access the dashboard by opening your web browser:\n\nMain Dashboard: http://localhost:8000/\n3D Visualization: http://localhost:8000/vessel3d.html",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#main-dashboard",
    "href": "rawFiles/WebVisualization/web_visualization.html#main-dashboard",
    "title": "Simulation Visualization Dashboard",
    "section": "Main Dashboard",
    "text": "Main Dashboard\nThe main dashboard (index.html) provides a comprehensive overview of the vessel‚Äôs state, sensor data, and control inputs.\n\nKey Features\n\nVessel Selection: Switch between different vessels in the simulation\nConnection Status: Real-time display of connectivity to the ROS2 environment\nVessel Information: Display of key vessel parameters (position, velocity, orientation)\nData Visualizations: Real-time charts for:\n\nVessel path and trajectory\nVelocities (linear and angular)\nOrientation (roll, pitch, yaw)\nControl surface positions\nThruster states\n\n\n\n\nDashboard Layout\nThe dashboard is organized in a responsive grid layout with cards for different data categories:\n\n\n\n\n\n\n\nSection\nDescription\n\n\n\n\nVessel Info\nBasic vessel parameters including position, velocities, and orientation\n\n\nPath Visualization\n2D trajectory visualization showing vessel movement in X-Y plane\n\n\nVessel Velocities\nCharts for surge (u), sway (v), and heave (w) velocities\n\n\nVessel Angular Rates\nCharts for roll rate (p), pitch rate (q), and yaw rate (r)\n\n\nOrientation\nCharts for roll (œï), pitch (Œ∏), and yaw (œà) angles\n\n\nControl Surfaces\nVisual representation of control surface positions\n\n\nThrusters\nVisual representation of thruster RPMs\n\n\n\n\n\nReal-time Data Updates\nThe dashboard updates in real-time with configurable update rates. Data collection begins automatically when connecting to a vessel and includes:\n\nSubscribe to /[vessel_name]/odometry_sim for position and velocity data\nSubscribe to /[vessel_name]/vessel_state for complete vessel state including actuators\nOptional subscription to additional sensor topics",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#d-visualization",
    "href": "rawFiles/WebVisualization/web_visualization.html#d-visualization",
    "title": "Simulation Visualization Dashboard",
    "section": "3D Visualization",
    "text": "3D Visualization\nThe 3D visualization (vessel3d.html) provides an interactive three-dimensional view of the vessel in its environment.\n\nKey Features\n\nReal-time Movement: The vessel model moves and rotates according to simulation data\nTrajectory Path: A colored trail showing the vessel‚Äôs path through the environment\nCustomizable View: Camera controls for rotating, panning, and zooming\nVessel Dimensions: Adjustable vessel size and proportions to match different vessel types\nFull-screen Mode: Expand the visualization to utilize the entire screen\n\n\n\nControls\nThe 3D view offers several interactive controls:\n\nOrbit: Click and drag to rotate the camera around the vessel\nPan: Right-click and drag (or middle-click and drag) to move the camera\nZoom: Scroll wheel to zoom in and out\nReset Camera: Button to restore the default camera position\nFullscreen: Button to toggle fullscreen mode\n\n\n\nVessel Model Customization\nYou can adjust the vessel‚Äôs appearance through the control panel:\n\nVessel Size: Overall scaling of the vessel model\nDimensions: Individual control over length, width, and height proportions\nApply Changes: Button to update the model with the new dimensions",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#integration-with-ros2",
    "href": "rawFiles/WebVisualization/web_visualization.html#integration-with-ros2",
    "title": "Simulation Visualization Dashboard",
    "section": "Integration with ROS2",
    "text": "Integration with ROS2\nThe visualization dashboard communicates with ROS2 using the ROS Bridge Server, which provides WebSocket connectivity between the ROS2 environment and web clients.\n\nCommunication Flow\n\nROS2 Topics to WebSockets: The ROS Bridge Server converts ROS2 topic messages to WebSocket messages\nWeb Client Processing: JavaScript code processes the WebSocket messages and updates the visualizations\nBidirectional Communication: The system supports both subscribing to and publishing ROS2 topics\n\n\n\nRequired ROS2 Components\nTo enable the visualization, the launch file includes:\n# HTTP server for web files\nExecuteProcess(\n    cmd=['python3', '-m', 'http.server', '8000', '--directory', web_build_dir],\n    name='http_server',\n    output='screen'\n),\n\n# ROS Bridge server for WebSocket communication\nIncludeLaunchDescription(\n    AnyLaunchDescriptionSource(rosbridge_launch)\n),\n\n\nTopic Subscriptions\nThe visualization automatically discovers vessel topics by querying available ROS2 topics. It looks for the following patterns:\n\n/&lt;vessel_name&gt;/odometry_sim: For vessel position and velocity\n/&lt;vessel_name&gt;/vessel_state: For complete vessel state including actuators",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#implementation-details",
    "href": "rawFiles/WebVisualization/web_visualization.html#implementation-details",
    "title": "Simulation Visualization Dashboard",
    "section": "Implementation Details",
    "text": "Implementation Details\nThe visualization dashboard is built using modern web technologies:\n\nChart.js: For responsive, interactive data visualization\nthree.js: For 3D rendering of the vessel\nroslibjs: For ROS2 communication via WebSockets\nResponsive Design: Automatically adapts to different screen sizes\n\n\nKey JavaScript Components\nThe system is organized into the following components:\n\nVesselManager: Handles vessel discovery, selection, and configuration\nVesselVisualizer: Manages data collection, processing, and visualization\n3D Rendering: Handles the three-dimensional visualization of vessels\n\n\n\nVessel State Representation\nThe dashboard visualizes the complete vessel state model:\n\nPosition: x, y, z (in meters)\nLinear Velocity: u, v, w (in m/s)\nAngular Velocity: p, q, r (in rad/s)\nOrientation: œï, Œ∏, œà (in degrees)\nActuators: Control surface angles (in degrees) and thruster RPMs",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#customization-options",
    "href": "rawFiles/WebVisualization/web_visualization.html#customization-options",
    "title": "Simulation Visualization Dashboard",
    "section": "Customization Options",
    "text": "Customization Options\nThe visualization can be customized in several ways:\n\nUpdate Rates: Chart refresh rates can be adjusted\nData Window: The amount of historical data displayed in charts\nVessel Configuration: The number of control surfaces and thrusters displayed\n3D Model: Vessel dimensions and appearance\nChart Scaling: Auto-rescaling and manual zoom/pan on charts",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#troubleshooting",
    "href": "rawFiles/WebVisualization/web_visualization.html#troubleshooting",
    "title": "Simulation Visualization Dashboard",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nConnection Issues\nIf the dashboard shows ‚ÄúDisconnected‚Äù status:\n\nEnsure the ROS Bridge server is running\nCheck that WebSocket port 9090 is accessible\nVerify the simulator is publishing required topics\n\n\n\nMissing Vessel Data\nIf vessel data isn‚Äôt displaying:\n\nSelect a vessel from the dropdown menu\nCheck ROS2 topics are being published:\nros2 topic list | grep vessel\nVerify message publication with:\nros2 topic echo /&lt;vessel_name&gt;/odometry_sim\n\n\n\nBrowser Compatibility\nThe visualization works best with modern browsers:\n\nGoogle Chrome\nMozilla Firefox\n\nMicrosoft Edge\nBrave Browser",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "rawFiles/WebVisualization/web_visualization.html#conclusion",
    "href": "rawFiles/WebVisualization/web_visualization.html#conclusion",
    "title": "Simulation Visualization Dashboard",
    "section": "Conclusion",
    "text": "Conclusion\nThe Panisim visualization dashboard provides a comprehensive interface for monitoring and interacting with simulated vessels. With its real-time updates, interactive charts, and 3D visualization, it offers a powerful tool for understanding vessel behavior and validating custom control or guidance algorithms.",
    "crumbs": [
      "Simulation Visualization Dashboard"
    ]
  },
  {
    "objectID": "index.html#key-feature",
    "href": "index.html#key-feature",
    "title": "Pani Simulator",
    "section": "Key Feature",
    "text": "Key Feature\n\nRealistic Physics: Follows dyanmics modelling as defined by Fossen‚Äôs \nModular Architecture: Easy integration of custom vessel models, sensors, and controllers\nROS2 Integration: Native support for Robot Operating System 2 (ROS2) for distributed robotics applications\nWeb Application: Lightweight web application for configuring and running the simulation\nMultiple Agents: Simulate multiple vessels in the same environment",
    "crumbs": [
      "Pani Simulator"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html",
    "href": "rawFiles/NoROS/noros.html",
    "title": "Running the simulator without ROS2",
    "section": "",
    "text": "Overview\nPanisim provides a standalone mode that allows you to run simulations without requiring the ROS2 middleware. This lightweight mode is ideal for quick testing, development, and scenarios where the full ROS2 ecosystem is not needed.\nThe non-ROS mode:",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#implementation-details",
    "href": "rawFiles/NoROS/noros.html#implementation-details",
    "title": "Running the simulator without ROS2",
    "section": "Implementation Details",
    "text": "Implementation Details\nThe non-ROS mode is implemented through two key components:\n\nsimulate_noros.py: A standalone script that initializes and runs the simulation\nclass_vessel.py: The core vessel class with a ros_flag parameter that controls ROS-specific behavior\n\n\n\n\n\n\nflowchart TB\n    subgraph Standard[\"ROS2 Mode\"]\n        ROS2[\"ROS2 Middleware\"]\n        ROS_Msgs[\"ROS Messages\"]\n        ROS_Nodes[\"ROS Nodes\"]\n        Vis[\"Web Visualization\"]\n    end\n    \n    subgraph NoROS[\"Non-ROS Mode\"]\n        NonROSSimScript[\"simulate_noros.py\"]\n        Terminal[\"Terminal Output\"]\n    end\n    \n    subgraph Core[\"Core Simulation\"]\n        Vessel[\"Vessel Class\"]\n        Dynamics[\"Vessel Dynamics\"]\n        Forces[\"Force Calculation\"]\n        ODE[\"ODE Solver\"]\n    end\n    \n    NonROSSimScript --&gt;|\"ros_flag=False\"| Vessel\n    ROS2 --&gt;|\"ros_flag=True\"| Vessel\n    \n    Vessel --&gt; Dynamics\n    Dynamics --&gt; Forces\n    Dynamics --&gt; ODE\n    \n    Vessel --&gt; ROS_Msgs\n    ROS_Msgs --&gt; ROS_Nodes\n    ROS_Nodes --&gt; Vis\n    \n    Vessel --&gt; Terminal\n    \n    classDef ros fill:#5D8AA8,stroke:#1F456E,color:white;\n    classDef noros fill:#6B8E23,stroke:#2E3B0F,color:white;\n    classDef core fill:#FF6347,stroke:#8B3626,color:white;\n    \n    class Standard,ROS2,ROS_Msgs,ROS_Nodes,Vis ros;\n    class NoROS,NonROSSimScript,Terminal noros;\n    class Core,Vessel,Dynamics,Forces,ODE core;\n\n\n\n\n\n\n\nThe ros_flag Parameter\nThe ros_flag parameter in the Vessel class constructor determines whether the vessel should use ROS2-specific functionality:\ndef __init__(self, vessel_params: Dict, hydrodynamic_data: Dict, vessel_id: int, ros_flag: bool = True):\n    \"\"\"Initialize vessel with parameters and hydrodynamic data.\n    \n    Args:\n        vessel_params: Dictionary containing vessel parameters\n        hydrodynamic_data: Dictionary containing hydrodynamic coefficients\n        vessel_id: Unique identifier for the vessel\n        ros_flag: Flag indicating whether to use ROS2 functionality\n    \"\"\"\n    self.ros_flag = ros_flag\n    # ... rest of initialization\nWhen ros_flag is set to False:\n\nNo ROS2 node is created for the vessel\nNo publishers or subscribers are established\nCommand inputs must be set directly in code or through custom control logic\nSimulation data is displayed in the terminal instead of through ROS2 topics",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#running-the-non-ros-simulator",
    "href": "rawFiles/NoROS/noros.html#running-the-non-ros-simulator",
    "title": "Running the simulator without ROS2",
    "section": "Running the Non-ROS Simulator",
    "text": "Running the Non-ROS Simulator\nTo run Panisim without ROS2:\n\nNavigate to the makara directory\nRun the simulate_noros.py script:\n\ncd /workspaces/mavlab/ros2_ws/src/mav_simulator/mav_simulator\npython3 simulate_noros.py\nThe simulation will use the same configuration files as the ROS2 version, loading vessel parameters, hydrodynamics, and initial conditions from the input files.\n\nSimulation Output\nThe non-ROS simulator provides detailed terminal output showing:\n\nSimulation time\nVessel position and orientation\nLinear and angular velocities\nForces acting on the vessel, including:\n\nHydrodynamic forces\nGravitational forces\nControl surface forces\nThruster forces\n\nControl surface angles\nThruster RPMs\n\nExample output:\nStarting simulation...\nTime [s] | Position [x, y, z] | Velocity [u, v, w]\n------------------------------------------------------------\n\nTime:   0.00\nPosition [x, y, z]: [  0.00,   0.00,   0.00]\nVelocity [u, v, w]: [  0.50,   0.00,   0.00]\nOrientation [phi, theta, psi] (deg): [  0.00,   0.00,   0.00]\nHydrodynamic forces: [ -0.40,   0.00,   0.00,   0.00,   0.00,   0.00]\nGravitational forces: [  0.00,   0.00,   0.00,   0.00,   0.00,   0.00]\nControl surface forces: [  0.00,   0.00,   0.00,   0.00,   0.00,   0.00]\nThruster forces: [  0.00,   0.00,   0.00,   0.00,   0.00,   0.00]\nControl surface angles [deg]: []\nThruster RPMs: []\n\nTime:   0.01\nPosition [x, y, z]: [  0.01,   0.00,   0.00]\nVelocity [u, v, w]: [  0.50,   0.00,   0.00]\n...",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#implementing-custom-controllers",
    "href": "rawFiles/NoROS/noros.html#implementing-custom-controllers",
    "title": "Running the simulator without ROS2",
    "section": "Implementing Custom Controllers",
    "text": "Implementing Custom Controllers\nOne of the key advantages of the non-ROS mode is the ability to easily implement custom controllers directly in the code. The vessel_ode method in class_vessel.py contains a section specifically for non-ROS mode:\nif not self.ros_flag:\n    ## TODO: Implement your controller logic here to get the actuator commands\n    \n    ## example\n    # if self.control_surface_control_type == 'fixed_rudder':\n    #     self.delta_c = con.fixed_rudder(t, state, n_control_surfaces, 10.0) #Enter rudder angle here\n    # elif self.control_surface_control_type == 'switching_rudder':\n    #     self.delta_c = con.switching_rudder(t, state, n_control_surfaces)\n    # else:\n    #     raise ValueError(f\"Invalid control surface control type: {self.control_surface_control_type}\")\n        \n    # # Get thruster commands\n    # if self.thruster_control_type == 'fixed_rpm':\n    #     self.n_c = con.fixed_thrust(t, state, n_thrusters,1000.0) #Enter RPM here\n    # else:\n    #     raise ValueError(f\"Invalid thruster control type: {self.thruster_control_type}\")\n    pass\nTo implement your own controller:\n\nCreate a controller module (e.g., my_controller.py) with your control algorithms\nImport your controller module in simulate_noros.py\nModify the vessel_ode method to use your controller:\n\n# In vessel_ode method of class_vessel.py\nif not self.ros_flag:\n    # Custom controller implementation\n    if hasattr(self, 'control_surface_control_type'):\n        if self.control_surface_control_type == 'my_controller':\n            self.delta_c = my_controller.calculate_rudder(t, state, self.n_control_surfaces)\n\nExample: Adding a Simple PID Controller\nHere‚Äôs an example of how to add a simple PID heading controller:\n\nCreate a controller module:\n\n# my_controller.py\nimport numpy as np\n\ndef pid_heading_controller(t, state, n_surfaces, desired_heading=0.0):\n    \"\"\"Simple PID heading controller.\n    \n    Args:\n        t: Current time\n        state: Vessel state vector\n        n_surfaces: Number of control surfaces\n        desired_heading: Target heading in radians\n        \n    Returns:\n        numpy.ndarray: Control surface angles in radians\n    \"\"\"\n    # Extract current heading\n    current_heading = state[11]  # psi is at index 11\n    \n    # Calculate heading error\n    heading_error = desired_heading - current_heading\n    \n    # Normalize to -pi to pi\n    heading_error = (heading_error + np.pi) % (2 * np.pi) - np.pi\n    \n    # PID gains\n    Kp = 0.5\n    Ki = 0.01\n    Kd = 0.1\n    \n    # Calculate PID terms (simplified - would need integral and derivative state)\n    p_term = Kp * heading_error\n    \n    # Calculate rudder command (assume first surface is main rudder)\n    rudder_angle = np.clip(p_term, -np.pi/4, np.pi/4)\n    \n    # Create control surface command array\n    delta_c = np.zeros(n_surfaces)\n    if n_surfaces &gt; 0:\n        delta_c[0] = rudder_angle\n    \n    return delta_c\n\nModify the vessel_ode method in class_vessel.py:\n\nif not self.ros_flag:\n    # Import controller at the top of the file\n    import my_controller\n    \n    # Use controller for rudder commands\n    self.delta_c = my_controller.pid_heading_controller(\n        t, state, self.n_control_surfaces, desired_heading=np.pi/4)  # 45 degrees\n    \n    # Set thruster commands if needed\n    if self.n_thrusters &gt; 0:\n        self.n_c = np.ones(self.n_thrusters) * 1000.0  # Fixed RPM",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#customizing-the-non-ros-simulator",
    "href": "rawFiles/NoROS/noros.html#customizing-the-non-ros-simulator",
    "title": "Running the simulator without ROS2",
    "section": "Customizing the Non-ROS Simulator",
    "text": "Customizing the Non-ROS Simulator\n\nModifying Simulation Parameters\nYou can customize the simulation by modifying the simulate_noros.py file:\n\nChange input file path:\nsim_params, agents = read_input(\"/path/to/your/custom_input.yml\")\nModify output format:\n# Customize the print statements in the simulation loop\nprint(f\"Custom format: time={vessel.t:6.2f}, position=[{pos[0]:6.2f}, {pos[1]:6.2f}]\")\nAdd data logging:\n# Add at the beginning of the simulate function\nimport csv\nlog_file = open('simulation_log.csv', 'w', newline='')\ncsv_writer = csv.writer(log_file)\ncsv_writer.writerow(['Time', 'X', 'Y', 'Z', 'U', 'V', 'W', 'P', 'Q', 'R', 'Phi', 'Theta', 'Psi'])\n\n# Inside the simulation loop\ncsv_writer.writerow([vessel.t, pos[0], pos[1], pos[2], vel[0], vel[1], vel[2], \n                    vessel.current_state[3], vessel.current_state[4], vessel.current_state[5],\n                    angles[0], angles[1], angles[2]])\n\n\n\nExtending the Simulator\nYou can extend the non-ROS simulator for specific use cases:\n\nBatch simulations:\ndef run_batch_simulations():\n    results = []\n    for initial_speed in [0.5, 1.0, 1.5, 2.0]:\n        sim_params, agents = read_input(\"/workspaces/mavlab/inputs/simulation_input.yml\")\n        agents[0]['vessel_config']['initial_conditions']['start_velocity'][0] = initial_speed\n        vessel = Vessel(agents[0]['vessel_config'], agents[0]['hydrodynamics'], vessel_id=0, ros_flag=False)\n        vessel.simulate()\n        # Extract results\n        final_pos = vessel.history[-1, 6:9]\n        results.append((initial_speed, final_pos))\n    return results\nParameter studies:\ndef parameter_study():\n    import matplotlib.pyplot as plt\n\n    turning_radii = []\n    rudder_angles = np.arange(-30, 31, 5) * np.pi / 180  # -30 to 30 degrees\n\n    for rudder_angle in rudder_angles:\n        # Set up simulation with fixed rudder angle\n        sim_params, agents = read_input(\"/workspaces/mavlab/inputs/simulation_input.yml\")\n        vessel = Vessel(agents[0]['vessel_config'], agents[0]['hydrodynamics'], vessel_id=0, ros_flag=False)\n\n        # Custom controller for fixed rudder\n        vessel.control_surface_control_type = 'fixed'\n        vessel.fixed_rudder_angle = rudder_angle\n\n        # Run simulation\n        vessel.simulate()\n\n        # Calculate turning radius from final path\n        # (simplified - would need actual path analysis)\n        path = vessel.history[:, 6:8]  # x, y positions\n        turning_radius = calculate_turning_radius(path)\n        turning_radii.append(turning_radius)\n\n    # Plot results\n    plt.plot(rudder_angles * 180 / np.pi, turning_radii)\n    plt.xlabel('Rudder Angle (degrees)')\n    plt.ylabel('Turning Radius (m)')\n    plt.savefig('turning_radius_study.png')",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#advantages-of-non-ros-mode",
    "href": "rawFiles/NoROS/noros.html#advantages-of-non-ros-mode",
    "title": "Running the simulator without ROS2",
    "section": "Advantages of Non-ROS Mode",
    "text": "Advantages of Non-ROS Mode\nThe non-ROS mode offers several advantages:\n\nSimplicity: No need to set up ROS2 environment or handle ROS-specific configurations\nPerformance: Lower overhead without ROS middleware, especially for rapid prototyping\nDebugging: Easier to debug core simulation components without ROS complexity\nQuick Testing: Fast iteration for testing vessel dynamics or controller concepts\nPortability: Can run anywhere Python is available, without ROS2 installation\nLearning: Excellent starting point for understanding vessel dynamics before moving to ROS2\nBatch Processing: Efficient for running multiple simulations for parameter studies or optimization",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#limitations",
    "href": "rawFiles/NoROS/noros.html#limitations",
    "title": "Running the simulator without ROS2",
    "section": "Limitations",
    "text": "Limitations\nCompared to the ROS2 mode, the non-ROS mode has some limitations:\n\nNo Visualization: Lacks the web-based visualization dashboard available in ROS2 mode\nLimited External Interaction: No standardized way to interact with external systems\nNo Distributed Simulation: Cannot distribute components across multiple processes/machines\nNo Standardized Messaging: No access to ROS2‚Äôs message types and communication patterns\nManual Data Collection: Requires custom code for data logging and analysis",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#conclusion",
    "href": "rawFiles/NoROS/noros.html#conclusion",
    "title": "Running the simulator without ROS2",
    "section": "Conclusion",
    "text": "Conclusion\nThe non-ROS mode provides a lightweight alternative for running Panisim simulations without the complexity of the ROS2 ecosystem. It‚Äôs particularly useful for rapid development, testing, and educational purposes. By understanding the implementation through ros_flag and custom controller integration, users can leverage this mode for a wide range of applications while still benefiting from Panisim‚Äôs accurate vessel dynamics modeling.",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  },
  {
    "objectID": "rawFiles/NoROS/noros.html#overview",
    "href": "rawFiles/NoROS/noros.html#overview",
    "title": "Running the simulator without ROS2",
    "section": "",
    "text": "Eliminates ROS2 dependencies and overhead\nProvides terminal-based feedback\nSupports the full vessel dynamics model\nAllows custom controller implementation\nSimplifies debugging of core simulation components",
    "crumbs": [
      "Running the simulator without ROS2"
    ]
  }
]